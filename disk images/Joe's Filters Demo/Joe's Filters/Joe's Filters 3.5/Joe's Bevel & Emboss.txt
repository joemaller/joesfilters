//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Bevel and Emboss";group "Joe's Alpha Effects";input bevType, "Bevel Type", popup, 1, "Inner Bevel", "Outer Bevel", "Emboss", "Pillow Emboss";input lightSRC, "Angle", Angle, 135, -360, 360;input shadowDistance, "Depth", Slider, 8, 0, 250 ramp 95;input shadowBlur, "Soften", Slider, 10, 0, 100 ramp 80;input shadowSpread, "Shrink/Grow", Slider, 0, -100, 100;input bgClip, "Background", Clipinput lightColor, "Light", Color, 255, 255, 255, 255;input lightOpacity, "Highlight Opacity", Slider, 75, 0, 100;input ApplyLight, "Highlight Mode", Popup, 1, "Normal", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference";input shadowColor, "Shadow", Color, 255, 0, 0, 0;input shadowOpacity, "Shadow Opacity", Slider, 75, 0, 100;input ApplyDark, "Shadow Mode", Popup, 1, "Normal", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference";input edges, "Opaque Edges", Checkbox, 0;input FXonly, "Effect Only", Checkbox, 0;input fader, "Original Opacity", Slider, 100, 0, 100;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";ProducesAlphaRenderEachFrameWhenStillcodeexposedbackground=1;lightSRC  += 360; //makes lightSRC a positive valuefloat w, h, j, shadowMin, shadowMax, adjKey[256], bgClipDuration, bgClipOffset;point startFrame[4], lightFrame[4], darkFrame[4];dimensionsof(dest, w, h);float zoomfactor; zoomfactor = w/720	image xbuffer[w][h], xbuffer2[w][h];boundsOf(dest, startframe);// first build the target frame by offsetting the source framefor j = 0 to 3;		lightFrame[j].x = startFrame[j].x + cos(lightSRC-90) * zoomfactor * shadowDistance)	lightFrame[j].y = startFrame[j].y + sin(lightSRC-90) * zoomfactor * shadowDistance / aspectOf(dest))	darkFrame[j].x = startFrame[j].x + cos(lightSRC+90) * zoomfactor * shadowDistance)	darkFrame[j].y = startFrame[j].y + sin(lightSRC+90) * zoomfactor * shadowDistance / aspectOf(dest))next;edges *= 255; 	//will equal either 0 or 255, to be used for the edge opacity fillchannelfill(xbuffer, edges, lightColor.r, lightColor.g, lightColor.b);channelfill(xbuffer2, edges, shadowColor.r, shadowColor.g, shadowColor.b);blitRect(src1, startframe, xbuffer, lightFrame);	//move the source imageblitRect(src1, startframe, xbuffer2, darkFrame);	//move the source imageif (shadowBlur > 0);//initally reverse the buffers, switch back during the blur	BlurChannel(xbuffer2, dest, shadowBlur/2 * zoomfactor, 1, 0, 0, 0, aspectOf(dest));	//blur alpha	BlurChannel(xbuffer, xbuffer2, shadowBlur/2 * zoomfactor, 1, 0, 0, 0, aspectOf(dest));	//blur alpha	if (shadowSpread == 0);		xbuffer = xbuffer2		xbuffer2 = dest	else		if shadowSpread < 0;			shadowMin = integer(shadowSpread/-100 * 254.99);			shadowMax = 255			shadowSpread = shadowMax - shadowMin;		else if shadowSpread > 0;			shadowMin = 0;			shadowMax = 255 - integer(shadowSpread/100 * 254.99);			shadowSpread = shadowMax - shadowMin;		end if		for j = 0 to 255;			adjKey[j] = (j < shadowMax) ? (j-shadowMin)/shadowSpread : 1		next;				levelMap(xbuffer2, xbuffer, adjKey, LinearRamp, LinearRamp, LinearRamp);		levelMap(dest, xbuffer2, adjKey, LinearRamp, LinearRamp, LinearRamp);			end if;end if;if bevType == 1;		// inner bevel	InvertChannel(xbuffer, xbuffer, 1, 0, 0, 0);	InvertChannel(xbuffer2, xbuffer2, 1, 0, 0, 0);		imageand(src1, xbuffer, xbuffer);	imageand(src1, xbuffer2, xbuffer2);else if bevType == 2;	// outer bevel	InvertChannel(xbuffer, xbuffer, 1, 0, 0, 0);	InvertChannel(xbuffer2, xbuffer2, 1, 0, 0, 0);		imageor(src1, xbuffer, xbuffer);	imageor(src1, xbuffer2, xbuffer2);else if bevType == 3;	// emboss	dest = xbuffer;	xbuffer = xbuffer2;	xbuffer2 = dest;else if bevType == 4;	// pillow emboss	dest = src1			//an xor bug seems to be doing something to corrupt src1 in FCP2 & 3, this is a workaround	imagexor(dest, xbuffer, xbuffer);	dest = src1; 	imagexor(dest, xbuffer2, xbuffer2);	dest = src1; end if		//the following is here because imageXor was causing terrible artifacts	InvertChannel(xbuffer, dest, 1, 0, 0, 0);	//move xbuffer into dest	add(xbuffer2, dest, dest, 1, kalpha);		InvertChannel(xbuffer2, xbuffer2, 1, 0, 0, 0);		add(xbuffer, xbuffer2, xbuffer2, 1, kalpha);	InvertChannel(dest, xbuffer, 1, 0, 0, 0);	InvertChannel(xbuffer2, xbuffer2, 1, 0, 0, 0);ChannelMultiply(xbuffer, xbuffer, lightOpacity/100, 0, 0, 0)	//handle light opacityChannelMultiply(xbuffer2, xbuffer2, shadowOpacity/100, 0, 0, 0)	//handle shadow opacityChannelFill(xbuffer, knone, lightColor.r, lightColor.g, lightColor.b);ChannelFill(xbuffer2, knone, shadowColor.r, shadowColor.g, shadowColor.b);// Background Video should be merged first, then composited in one stepgetLimits(bgClip, bgClipDuration, bgClipOffset);if bgClipDuration > 0	//background clip existsdest = src1;	getvideo(bgClip,  bgClipOffset  + frame/2, dest);		Matte(src1, dest, dest, fader/100, kalpha)else;	ChannelMultiply(src1, dest, fader/100, 1, 1, 1)	//handle light opacityend ifif FXonly == 0	if ApplyLight == 1; Matte(xbuffer, dest, dest, 1, kalpha); end if	if ApplyDark == 1; Matte(xbuffer2, dest, dest, 1, kalpha); end if		if ApplyLight == 2; Multiply(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 2; Multiply(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 3; Screen(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 3; Screen(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 4; Overlay(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 4; Overlay(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 5; Lighten(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 5; Lighten(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 6; Darken(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 6; Darken(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 7; add(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 7; add(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 8; subtract(dest, xbuffer, dest, 1, kalpha); end if	if ApplyDark == 8; subtract(dest, xbuffer2, dest, 1, kalpha); end if		if ApplyLight == 9; Difference(dest, xbuffer, dest, kalpha); end if	if ApplyDark == 9; Difference(dest, xbuffer2, dest, kalpha); end ifend if;