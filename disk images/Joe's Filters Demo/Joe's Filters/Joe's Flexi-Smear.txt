//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Flexi-Smear";group "Joe's Stylize Filters";input Mover, "Intensity", Slider, 1, 0, 10;input ULangle, "UL", Angle, 0, -360, 360;input ULvalue, "UL intensity", Slider, 1, 0, 5;input URangle, "UR", Angle, 0, -360, 360;input URvalue, "UR intensity", Slider, 1, 0, 5;input LLangle, "LL", Angle, 0, -360, 360;input LLvalue, "LL intensity", Slider, 1, 0, 5;input LRangle, "LR", Angle, 0, -360, 360;input LRvalue, "LR intensity", Slider, 1, 0, 5;input noTear, "No Tearing", Checkbox, 0input wiggler, "Wiggle", Slider, 0, 0, 10;	// randomizer for intensityinput jiggler, "Jiggle", Slider, 0, 0, 10;	// randomizer for angleinput title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";RenderEachFrameWhenStillcodefloat w, h, i;point trueFrame[4], bentFrame[4];DimensionsOf(dest, w, h);float zoomfactor; zoomfactor = w/720	wiggler/=50;jiggler/=10;// each corner has an angle and a value, the actual offset is calculated by taking the COS/SIN// and multiplying this by the value. This results in two numbers which are the offsets.// adding these extra variables to clean up the second rectagle declaration// I multiplied the point by the corner value just to be tricky, and i thought it was cool.point UL, UR, LL, LR;UL.x = cos(ULangle-90 + jiggler * random(-30,30)); UL.y = sin(ULangle-90 + jiggler * random(-30,30));UL *= Mover * (ULvalue + wiggler * random(-20,20)) * zoomfactor;UR.x = cos(URangle-90 + jiggler * random(-30,30)); UR.y = sin(URangle-90 + jiggler * random(-30,30));UR *= Mover * (URvalue + wiggler * random(-20,20)) * zoomfactor;LR.x = cos(LRangle-90 + jiggler * random(-30,30)); LR.y = sin(LRangle-90 + jiggler * random(-30,30));LR *= Mover * (LRvalue + wiggler * random(-20,20)) * zoomfactor;LL.x = cos(LLangle-90 + jiggler * random(-30,30)); LL.y = sin(LLangle-90 + jiggler * random(-30,30));LL *= Mover * (LLvalue + wiggler * random(-20,20)) * zoomfactor;BoundsOf(dest, trueFrame)bentFrame[0] = {trueFrame[0].x + UL.x, trueFrame[0].y + UL.y};bentFrame[1] = {trueFrame[1].x + UR.x, trueFrame[1].y + UR.y};bentFrame[2] = {trueFrame[2].x + LR.x, trueFrame[2].y + LR.y};bentFrame[3] = {trueFrame[3].x + LL.x, trueFrame[3].y + LL.y};if GetPixelFormat(dest) != kFormatRGB219;	image xbuffer[w][h];	float colorSpace;	colorSpace = GetPixelFormat(dest);			//store this for reverse conversion later on		if noTear == 0;		ConvertImage(src1, dest, kFormatRGB219);		BlitRect(dest, trueFrame, dest, bentFrame);	else		ConvertImage(src1, xbuffer, kFormatRGB219);		setpixelformat(dest, kFormatRGB219);		channelFill(dest, 0,0,0,0);		BlitRect(xbuffer, trueFrame, dest, bentFrame);	end if;		ConvertImage(dest, xbuffer, colorSpace);	setpixelformat(dest, colorSpace)	dest = xbuffer;		else	if noTear == 0;		dest = src1;		BlitRect(dest, trueFrame, dest, bentFrame);	else		channelFill(dest, 0,0,0,0);		BlitRect(src1, trueFrame, dest, bentFrame);	end if;end if;