//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Maximizer";group "Joe's Stylize Filters";input Shifter, "Iterations", Slider, 3, 1, 20 snap 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20input stepValue, "Spacing", Slider, 2, 1, 50 ramp 70;input numSides, "Sides", Slider, 4, 2, 12 detent 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12;input ShapeAngle, "Angle", Angle, 0, -360, 360;input blendMethod, "Method", RadioGroup, 1, "Lighten", "Darken", "Screen", "Multiply";input inBlur, "Blur Iterations", Slider, 0, 0, 10;input falloffcheck, "Falloff", checkbox, 0;input easing, "Falloff Easing", Slider, 1, 0.1, 10 ramp 93.5 detent 1;input bwo, "Blend With Original:", Label,"";input ApplyAs, "Mode", Popup, 1, "Normal", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference";input Opacity, "Opacity", slider, 100, 0, 100;input PreserveAlpha, "Preserve Alpha", checkbox, 0;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";ProducesAlphacodeexposedbackground=1float h, w, i, j, k, q, RGBvalueFix, angleFix, falloff, adjKey[256], whiteCap, blackCap;point startFrame[4], endFrame[4];dimensionsof(dest, w, h);image xbuffer[w][h], xbuffer2[w][h], tempbuffer[w][h];float zoomfactor; zoomfactor = w/720	boundsOf(dest, startframe);RGBvalueFix = (blendMethod == 1 || blendmethod == 3) ? 0: 255;		//lighten needs a frame of pure black, darken needs a frame of pure white, these are used to correct the color fill in  the main loopangleFix = (numSides == 4 || numSides == 6 || numSides == 8) ? 360/numsides/2 : 0			// corrects the rotation of squares, hexagons and octagons, which I prefer flat-side topdest = src1;	//fills the output frame so there's something to blend withfor i = 1 to Shifter;	ChannelFill(tempbuffer, 255, RGBvalueFix, RGBvalueFix, RGBvalueFix)	for k = 0 to numSides-1;		ChannelFill(xbuffer, -1, RGBvalueFix, RGBvalueFix, RGBvalueFix); //clears xbuffer for blit offset				for j = 0 to 3;					//builds the offset frame which always has four sides, thus 0 through 3 (1 to 4)			endframe[j].x = startFrame[j].x + (cos(360/numSides * k + ShapeAngle-90 - angleFix) * zoomfactor * stepValue)			endframe[j].y = startFrame[j].y + (sin(360/numSides * k + ShapeAngle-90 - angleFix) * zoomfactor * stepValue / aspectOf(dest))		next;					blitRect(dest, startframe, xbuffer, endFrame);		// copies the original image to the offset		if blendMethod == 1; lighten(xbuffer, tempbuffer, tempbuffer, 1, kwhite); end if;		if blendMethod == 2; darken(xbuffer, tempbuffer, tempbuffer, 1, kblack); end if;		if blendMethod == 3; 					whiteCap = 255	// sets the white input level			blackCap = 128	// sets the white output level						for q = 0 to 255				adjKey[q] = (q < whiteCap) ? (q-blackCap)/(whiteCap - blackCap): 1; 			next						levelMap(xbuffer, xbuffer2, LinearRamp, adjkey, adjkey, adjkey);			screen(xbuffer2, tempbuffer, tempbuffer, 1, kalpha); 		end if;		if blendMethod == 4; 					whiteCap = 128	// sets the white input level			blackCap = 0	// sets the white output level						for q = 0 to 255				adjKey[q] = (q < whiteCap) ? (q-blackCap)/(whiteCap - blackCap): 1; 			next						levelMap(xbuffer, xbuffer2, LinearRamp, adjkey, adjkey, adjkey);			multiply(xbuffer2, tempbuffer, tempbuffer, 1, kalpha); 		end if;	next;					falloff = (falloffcheck == 1) ? power(((shifter + 1 - i)/ shifter), easing) : 1;	 if inBlur >0	xbuffer = tempbuffer	Blur(xbuffer, tempbuffer, inBlur * ((shifter + 1 - i)/ shifter), aspectof(dest))	//blurs the pre-composite frame - Radius decreases with each iteration.end if	if blendMethod == 1; lighten(dest, tempbuffer, dest, falloff, kwhite); 	else if blendMethod == 2; darken(dest, tempbuffer, dest, falloff, kblack); 	else if blendMethod == 3; screen(dest, tempbuffer, dest, falloff, kalpha); 	else if blendMethod == 4; multiply(dest, tempbuffer, dest, falloff, kalpha); 	end if;next;if PreserveAlpha==1;		ChannelCopy(src1, dest, kalpha, knone, knone, knone)end ifif ApplyAs == 1 && opacity < 100; Matte(dest, src1, dest, opacity/100, kalpha); end if; //image is already in dest, no need to composite unless opacity is < 100if ApplyAs == 2; Multiply(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 3; Screen(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 4; Overlay(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 5; Lighten(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 6; Darken(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 7; add(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 8; subtract(src1, xbuffer2, dest, opacity/100, kalpha); end if;if ApplyAs == 9; 		Difference(src1, xbuffer2, dest, kalpha); 		ChannelCopy(src1, dest, kalpha, knone, knone, knone); 		Matte(dest, src1,  dest, opacity/100, knone); end if;