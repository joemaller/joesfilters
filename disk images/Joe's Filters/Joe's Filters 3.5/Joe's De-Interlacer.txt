//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's De-Interlacer";group "Joe's Video & Time Filters";input label0, "De-Interlace", label, "";input FieldPicker, "Field", RadioGroup, 1, "Upper Field (odd)", "Lower Field (even)";input FieldMethod, "Method", popup, 3, "Field Double", "Interpolate", "Fast Interpolate";input label1, "Motion Differencing", label, "";input motiondiff, "Motion Difference", checkbox, 1;input RGBorYUV, "Difference Using", popup, 2, "RGB", "Luma";input threshold, "Threshold", slider, 225, 128, 254;input blurradius, "Soften", slider, 2.5, 0, 10;input label2, "Mask Check", label, "";input showthis, "View", popup, 1, "Merged Output", "Motion Mask", "Colorize Motion";input maskcolor, "Mask Color", color, 255, 128, 0, 255;input maskopacity, "Color Opacity", slider, 60, 0, 100 label "%";input label3, "Fade With Original", label, "";input opacity, "Opacity", slider, 100, 0, 100;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware");fullframeProducesAlphacodeexposedbackground=1float clipdur, clipoffset, adjkey[256], i, j, colorspace;point infieldUP[4], infieldDOWN[4], outfield[4];boundsOf(dest, infieldUP);image xbuffer[(infieldUP[1].x - infieldUP[0].x)][(infieldUP[2].y - infieldUP[0].y)];				//full size bufferimage xbuffer2[(infieldUP[1].x - infieldUP[0].x)][(infieldUP[2].y - infieldUP[0].y)];				//full size bufferimage halfBuffer[(infieldUP[1].x - infieldUP[0].x)][((infieldUP[2].y - infieldUP[0].y) * 0.5)];		//half height bufferboundsOf(halfbuffer, outfield);fieldPicker -=1; //make this either 0 or 1colorSpace = GetPixelFormat(dest);	getLimits(clip1, clipdur, clipoffset)getVideo(clip1, -clipoffset + frame - 1, xbuffer);getVideo(clip1, -clipoffset + frame + 1, xbuffer2);if RGBorYUV == 1 //RGB	if GetPixelFormat(dest) != kFormatRGB255;		ConvertImage(src1, dest, kFormatRGB255);		ConvertImage(xbuffer, xbuffer, kFormatRGB255);		ConvertImage(xbuffer2, xbuffer2, kFormatRGB255);	else		dest = src1;	end if;else // YUV	if GetPixelFormat(dest) != kFormatYUV219;		ConvertImage(src1, dest, kFormatYUV219);		ConvertImage(xbuffer, xbuffer, kFormatYUV219);		ConvertImage(xbuffer2, xbuffer2, kFormatYUV219);	else		dest = src1;	end if;end if;if motiondiff	// begin motion differencing routines	difference(xbuffer, dest, xbuffer, kalpha);	difference(xbuffer2, dest, xbuffer2, kalpha);		Add(xbuffer, xbuffer2, dest, 1, kalpha);	InvertChannel(dest, dest, 0, 1, (RGBorYUV * -1 + 2), (RGBorYUV * -1 + 2))				if RGBorYUV == 1 //RGB		Desaturate(dest, xbuffer);			// average the values of the three channels 	end if		adjKey *= 0;	for j = threshold to 255;		adjKey[j] = 1;	next;		levelMap(dest, xbuffer, LinearRamp, adjKey, LinearRamp, LinearRamp);		if blurradius > 0		BlurChannel(xbuffer, dest, blurradius, 0, 1, 0, 0, 10);	else		xbuffer = dest;	end if		if RGBorYUV == 1 //RGB		channelcopy(dest, dest, knone, kred, kred, kred);	end if	end if	//end motion differencing routinesif RGBorYUV == 1 //RGB	if GetPixelFormat(dest) != kFormatRGB255;		ConvertImage(src1, xbuffer2, kFormatRGB255);	else		xbuffer2 = src1;	end if;else // YUV	if GetPixelFormat(dest) != kFormatYUV219;		ConvertImage(src1, xbuffer2, kFormatYUV219);	else		xbuffer2 = src1;	end if;end if;channelcopy(dest, dest, kred, knone, knone, knone);channelcopy(xbuffer2, dest, knone, kred, kgreen, kblue);if FieldMethod == 1 	//interpolate or field double	 for i = infieldUP[0].y to infieldUP[2].y step 2;			infieldUP[0].y = i + FieldPicker;				infieldUP[1].y = i + FieldPicker;			infieldUP[2].y = i + 1 + FieldPicker;		infieldUP[3].y = i + 1 + FieldPicker;		outfield[0].y = infieldUP[0].y + 1;		outfield[1].y = infieldUP[1].y + 1;			outfield[2].y = infieldUP[2].y + 1;		outfield[3].y = infieldUP[3].y + 1;						BlitRect(xbuffer2, infieldUP, xbuffer2, outfield);	next;else if FieldMethod == 2;		// interlace, expand halfbuffer into xbuffer		j = outfield[0].y		for i = infieldUP[0].y to infieldUP[2].y step 2;			infieldUP[0].y = i + FieldPicker;				infieldUP[1].y = i + FieldPicker;			infieldUP[2].y = i + 1 + FieldPicker;		infieldUP[3].y = i + 1 + FieldPicker;					outfield[0].y = j;	// j starts at the topmost row of pixels in outfield and counts up		outfield[1].y = j;			outfield[2].y = j + 1;		outfield[3].y = j + 1;						j++		// increases the target row, used to build a half-height image.					BlitRect(xbuffer2, infieldUP, halfbuffer, outfield); // copy the contents of the selected field	next;		BoundsOf(halfbuffer, infieldUP);	BoundsOf(dest, outfield);	BlitRect(halfbuffer, infieldUP, xbuffer2, outfield);else if FieldMethod == 3 // fast de-interlace, squish vertically then expand	BoundsOf(dest, infieldUP);	BoundsOf(halfbuffer, outfield); 			infieldUP[0].y +=  FieldPicker;	infieldUP[1].y +=  FieldPicker;;		infieldUP[2].y +=  FieldPicker;;	infieldUP[3].y +=  FieldPicker;;			BlitRect(xbuffer2, infieldUP, halfbuffer, outfield)  		//squish the original frame by half		infieldUP[0].y -=  FieldPicker;	infieldUP[1].y -=  FieldPicker;;		infieldUP[2].y -=  FieldPicker;;	infieldUP[3].y -=  FieldPicker;;			BlitRect(halfbuffer, outfield, xbuffer2, infieldUP)  	//expand the squished imageend ifif showthis == 1	if motiondiff		matte(dest, xbuffer2, dest, 1, kalpha);	else // deinterlace only		dest = xbuffer2;	end ifelse if showthis == 2	if motiondiff		if GetPixelFormat(xbuffer) != kFormatYUV219;			channelfill(xbuffer, 255, 0, 0, 0);		else			channelfill(xbuffer, 255, 0, 128, 128);		end if		if GetPixelFormat(dest) != kFormatYUV219;			channelfill(dest, -1, 255, 255, 255);		else			channelfill(dest, -1, 255, 128, 128);		end if		matte(dest, xbuffer, dest, 1, kalpha);	else 		if GetPixelFormat(dest) != kFormatYUV219;			channelfill(dest, 255, 255, 255, 255);		else			channelfill(dest, 255, 255, 128, 128);		end if	end if	else if showthis == 3	// color check	if motiondiff		invertchannel(dest, xbuffer, 1, 0, 0, 0);		channelmultiply(xbuffer, xbuffer, maskopacity/100, 0, 0, 0);		if GetPixelFormat(xbuffer) == kFormatYUV219;			channelfill(xbuffer, -1, maskcolor.r * 0.299 + maskcolor.g * 0.587 + maskcolor.b * 0.114, maskcolor.r * -0.169 + maskcolor.g * -0.332 + maskcolor.b * 0.500 + 128, maskcolor.r * 0.500 + maskcolor.g * -0.419 + maskcolor.b * -0.0813 + 128);		else			channelfill(xbuffer, -1, maskcolor.r, maskcolor.g , maskcolor.b);		end if		channelfill(dest, 255, -1, -1, -1)		matte(xbuffer, dest, dest, 1, kalpha);	else		if GetPixelFormat(dest) == kFormatYUV219;			channelfill(dest, 255, maskcolor.r * 0.299 + maskcolor.g * 0.587 + maskcolor.b * 0.114, maskcolor.r * -0.169 + maskcolor.g * -0.332 + maskcolor.b * 0.500 + 128, maskcolor.r * 0.500 + maskcolor.g * -0.419 + maskcolor.b * -0.0813 + 128);		else			channelfill(dest, 255, maskcolor.r, maskcolor.g , maskcolor.b);		end if	end ifend ifif colorSpace != GetPixelFormat(dest)	ConvertImage(dest, dest, colorspace);end ifif opacity < 100	matte(dest, src1, dest, opacity/100, kalpha);end if