//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Broadcast Legalizer";group "Joe's Video & Time Filters";input label0, "Luma Adjustment", Label, "";input lumaCap, "Ceiling", Slider, 100, 70, 110 label "IRE" detent 75, 100;input lumaLow, "Floor", Slider, 7.5, 0, 25 label "IRE" detent 7.5 input label1, "Chroma Adjustment", Label, "";input chromaCap, "Amplitude", Slider, 0, -100, 0; //change last number to 100 to experiment with saturation via compressed chromainput chromaShift, "Phase", angle, 0, -360, 360;input chomaOffset, "Offset", slider, 0, 0, 112;input label2, "Y/C Correction", Label, "";input target, "Target", radiogroup, 1, "Both", "Luma (Y)", "Chroma (C)";input Horizontal, "Horizontal", slider, 0, -10, 10;input Vertical, "Vertical", slider, 0, -10, 10;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware")ProducesAlpha;codeexposedbackground = 1;float i, j, w, h, colorSpace, yctool, lumaKey[256], chromaKey[256], chromaRange, chromaUp, chromaDown, chromaKey2[256];point srcRect[4], destRect1[4], destRect2[4];colorSpace = GetPixelFormat(dest);					//store this for final conversion at the enddimensionsOf(Dest, w, h);image xbuffer[w][h];float zoomfactor; zoomfactor = w/720;if GetPixelFormat(src1) != kFormatYUV219;	ConvertImage(src1, src1, kFormatYUV219);		// dest contains offset image	setpixelformat(dest, kFormatYUV219)	setpixelformat(xbuffer, kFormatYUV219)end if// Luma/Chroma Adjustment section (that doesn't rhyme!)if (lumaCap < 110 || lumaLow > 0 || chromaCap != 100 || chromaShift != 0 || chomaOffset > 0)	lumaCap = lumaCap/110 * 241;	//I don't know why 241 is the magic number, but this matches FCP's Waveform scopes exactly...	lumaLow = lumaLow/110 * 241;		lumaKey = linearRamp;	lumaKey *= lumaCap - lumaLow;	lumaKey += lumaLow;	lumaKey /= 255;		chromaKey = linearRamp;			chromaKey2 = chromaKey;	chromaKey += chomaOffset/255 * sin(chromaShift);		// offset chroma	chromaKey2 += chomaOffset/255 * cos(chromaShift);			if chromaCap < 0 					// desaturate, same as compressing output levels				chromaCap = 1 + chromaCap/100					//makes it a decimal value			chromaKey *= (chromaCap * 255);					//multiplies everything by the total number of output values		chromaKey2 *= (chromaCap * 255);					//multiplies everything by the total number of output values			chromaKey += 255/2 -(chromaCap * 255)/2;			//increases the clut by the output black, sets the bottommost level		chromaKey2 += 255/2 -(chromaCap * 255)/2;			//increases the clut by the output black, sets the bottommost level			chromaKey /= 255;							//corrects the total clut to make sure all 255 values fall between 0 and 1			chromaKey2 /= 255;							//corrects the total clut to make sure all 255 values fall between 0 and 1		 	 else if chromaCap > 0				// enable this by changing the Chroma input range, saturate, same as compressing input levels				chromaUp = (255/2 + (100-chromaCap)/100 * 255/2);		chromaDown = (255/2 - (100-chromaCap)/100 * 255/2);		chromaRange = (chromaUp - chromaDown > 0) ? chromaUp - chromaDown : 1				for i = 0 to 255			chromaKey[i] = (i < chromaUp) ? (i - chromaDown)/chromaRange: 1; 			chromaKey2[i] = (i < chromaUp) ? (i - chromaDown)/chromaRange: 1; 		next;	end if				levelMap(src1, dest, LinearRamp, lumaKey, chromaKey, chromaKey2);else	dest = src1;end if//Y/C Correction section (that rhymes!)if (Horizontal != 0 || Vertical != 0)	boundsOf(dest, srcRect);	destRect1 = srcRect;	destRect2 = srcRect;		yctool = (target == 1) ? 2 : 1;		for i = 0 to 3;		destRect1[i].x += Horizontal/yctool * zoomfactor;			destRect1[i].y += Vertical/yctool * zoomfactor;		destRect2[i].x += Horizontal/-yctool * zoomfactor;			destRect2[i].y += Vertical/-yctool * zoomfactor;	next;		ChannelFill(xbuffer, 0, 0, 128, 128);		BlitRect(dest, srcRect, xbuffer, destRect1)		//  full image		if (target == 1)		ChannelCopy(xbuffer, dest, knone, kred, knone, knone);		// move offset luma back into dest		ChannelFill(xbuffer, 0, 0, 128, 128);						// blank the image buffer again		BlitRect(dest, srcRect, xbuffer, destRect2)					// Chroma		ChannelCopy(xbuffer, dest, knone, knone, kgreen, kblue);	// move offset chroma back into dest	else if (target == 2)		ChannelCopy(xbuffer, dest, knone, kred, knone, knone);		// move offset luma back onto original chroma	else if (target == 3)		ChannelCopy(xbuffer, dest, knone, knone, kgreen, kblue);		// move original luma onto offset chroma	end if			ChannelCopy(src1, dest, kalpha, knone, knone, knone);		// restore alphaend ifif GetPixelFormat(dest) != colorSpace;				ConvertImage(dest, dest, colorSpace);end if