//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Drop Shadow";group "Joe's Alpha Effects";input shadowColor, "Color", Color, 255, 0, 0, 0;input lightSRC, "Angle", Angle, 135, -360, 360;input shadowDistance, "Distance", Slider, 15, 0, 1000 ramp 90;input shadowBlur, "Soften", Slider, 10, 0, 250 ramp 75;input shadowSpread, "Shrink/Grow", Slider, 0, -100, 100;input edges, "Opaque Edges", Checkbox, 0;input shadowOpacity, "Opacity", Slider, 75, 0, 100;input FXonly, "Effect Only", Checkbox, 0;input knockout, "Knockout Source", Checkbox, 0;input bgClip, "Background", Clipinput ApplyAs, "Mode", Popup, 2, "Normal", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference";input hint, "Set clip to Straight Alpha Type,", Label,"";input hint2, "for correct compositing", Label,"";input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";ProducesAlphacodeexposedbackground=1lightSRC  += 360; //makes lightSRC a positive valuefloat w, h, j, shadowMin, shadowMax, adjKey[256], bgClipDuration, bgClipOffset;point startFrame[4], endFrame[4];dimensionsof(dest, w, h);float zoomfactor; zoomfactor = w/720	image xbuffer[w][h];boundsOf(dest, startframe);// first build the target frame by offsetting the source framefor j = 0 to 3;		endframe[j].x = startFrame[j].x + cos(lightSRC-90) * zoomfactor * shadowDistance)	endframe[j].y = startFrame[j].y + sin(lightSRC-90) * zoomfactor * shadowDistance / aspectOf(dest))next;edges *= 255; 	//will equal either 0 or 255, to be used for the edge opacity fillchannelfill(xbuffer, edges, shadowColor.r, shadowColor.g, shadowColor.b);blitRect(src1, startframe, xbuffer, endFrame);	//move the source imageif (shadowBlur == 0);	dest=xbuffer;else;	BlurChannel(xbuffer, dest, shadowBlur/2 * zoomfactor, 1, 0, 0, 0, aspectOf(dest));	//blur alpha	if (shadowSpread != 0);		if shadowSpread < 0;			shadowMin = integer(shadowSpread/-100 * 254);			shadowMax = 255			shadowSpread = shadowMax - shadowMin;		else if shadowSpread > 0;			shadowMin = 0;			shadowMax = 255 - integer(shadowSpread/100 * 254);			shadowSpread = shadowMax - shadowMin;		end if		for j = 0 to 255;			adjKey[j] = (j < shadowMax) ? (j-shadowMin)/shadowSpread : 1		next;				levelMap(dest, xbuffer, adjKey, LinearRamp, LinearRamp, LinearRamp);		dest = xbuffer;	end if;end if;if knockout == 1	InvertChannel(dest, dest, 1, 0, 0, 0);		ImageOr(src1, dest, dest);	InvertChannel(dest, dest, 1, 0, 0, 0);	end if;ChannelMultiply(dest, dest, shadowOpacity/100, 0, 0, 0)	//handle shadow opacityChannelFill(dest, knone, shadowColor.r, shadowColor.g, shadowColor.b);getLimits(bgClip, bgClipDuration, bgClipOffset);if bgClipDuration > 0	//background clip exists	getvideo(bgClip, bgClipOffset + frame, xbuffer);	if ApplyAs == 1; Matte(dest, xbuffer, dest, 1, kalpha); end if	if ApplyAs == 2; Multiply(xbuffer, dest, dest, 1, kwhite); end if	if ApplyAs == 3; Screen(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 4; Overlay(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 5; Lighten(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 6; Darken(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 7; add(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 8; subtract(xbuffer, dest, dest, 1, kalpha); end if	if ApplyAs == 9; Difference(xbuffer, dest, dest, kalpha); end ifend ifif FXonly == 0	matte(src1, dest, dest, 1, kalpha);end if