//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Soft Ellipse";group "Joe's Soft Stuff";input OvalWidth, "Width", Slider, 150, 1, 1000 ramp 80;input OvalHeight, "Height", Slider, 200, 1, 1000 ramp 80;input ShapeScale, "Scale", Slider, 100, 1, 1000;input origin, "origin", point, 0, 0;input ShapeAngle, "Angle", Angle, 0, -360, 360;input BlurAmount, "Blur", Slider, 10, 0, 250 ramp 85;input MaskBlur, "Softness", Slider, 5, 0, 250 ramp 85;input SpotInvert, "Invert", checkbox, 0;input ApplyAs, "Mode", Popup, 1, "Normal", "Shape Only", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference";input Opacity, "Opacity", slider, 100, 0, 100;input shape, "Shape Preview", Label,"";input shapePreview, "Draw Shape", checkbox, 0;input frameColor, "Frame Color", color, 255, 255, 255, 255;input frameWidth, "Frame Width", slider, 2, 1, 25;input frameSoft, "Frame Softness", slider, 0, 0, 25;input frameOpacity, "Frame Opacity", slider, 50, 0, 100;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";ProducesAlphacodeexposedbackground=1float h, w, i;point OvalRect[4], SourceRect[4], DestRect[4];						//ovalrect is the shape of the oval, source is the sample to copy from, destrect is the one to copy todimensionsof(dest, w, h);image xbuffer[w][h];float zoomfactor; zoomfactor = w/720;	image scalebuffer[(ShapeScale/100 * OvalWidth + framewidth + 10) * zoomfactor][(ShapeScale/100 * OvalHeight + framewidth + 10) * zoomfactor]	//make a new image buffer to contain the ovalorigin.x *= w;														//converts FXScript point values into pixel coordinatesorigin.y *= h;OvalRect[0] = {OvalWidth/-2, OvalHeight/ 2/ aspectOf(dest)};		//builds a box around the centerpoint to contain the ovalOvalRect[1] = {OvalWidth/ 2, OvalHeight/ 2/ aspectOf(dest)};OvalRect[2] = {OvalWidth/ 2, OvalHeight/-2/ aspectOf(dest)};OvalRect[3] = {OvalWidth/-2, OvalHeight/-2/ aspectOf(dest)};OvalRect *= ShapeScale/100;												//instead of multiplying every line above by zoomfactorOvalRect *= zoomfactor;												//instead of multiplying every line above by zoomfactorChannelFill(scalebuffer, 255, 0, 0, 0);								//fill the new image buffer with blank pixelsFillOval(ovalRect, scalebuffer, kwhite);							//draws the filled oval which will become the maskBoundsof(scalebuffer, SourceRect)DestRect = SourceRect; 												//duplicates SourceRect into DestRectfor i = 0 to 3;	DestRect[i].x += origin.x;										//moves DestRect to the origin point	DestRect[i].y += origin.y;next;Rotate(DestRect, origin, ShapeAngle, aspectOf(dest));				//rotates the destination shape NOT the pixels around the origin pointChannelFill(dest, 255, 0, 0, 0);									//sets a clean background to receive the rotated pixelsBlitRect(scalebuffer, SourceRect, dest, DestRect)					//copies and rotates the source pixelsif MaskBlur > 0;	Blur(dest, xbuffer, MaskBlur * zoomfactor, aspectof(dest));else	xbuffer = dest;end if;Blur(src1, dest, BlurAmount * zoomfactor, aspectOf(dest));ChannelCopy(xbuffer, dest, kred, knone, knone, knone);				// copy the alpha channel oval from xbuffer to destxbuffer = destif SpotInvert == 1	InvertChannel(xbuffer, xbuffer, 1, 0, 0, 0)end ifif ApplyAs == 1; Matte(xbuffer, src1, dest, opacity/100, kalpha); end ifif ApplyAs == 2; 	ChannelFill(dest, 0, 0, 0, 0);	ChannelMultiply(xbuffer, dest, opacity/100, 1, 1, 1); end if;if ApplyAs == 3; Multiply(src1, xbuffer, dest, opacity/100, kalpha); end ifif ApplyAs == 4; Screen(src1, xbuffer, dest, opacity/100, kalpha); end ifif ApplyAs == 5; Overlay(src1, xbuffer, dest, opacity/100, kalpha); end ifif ApplyAs == 6; Lighten(src1, xbuffer, dest, opacity/100, kalpha); end ifif ApplyAs == 7; Darken(src1, xbuffer, dest, opacity/100, kalpha); end ifif ApplyAs == 8; add(src1, xbuffer, dest, opacity/100, kalpha); end if;if ApplyAs == 9; subtract(src1, xbuffer, dest, opacity/100, kalpha); end if;if ApplyAs == 10; 		Difference(src1, xbuffer, dest, kalpha); 		ChannelCopy(src1, dest, kalpha, knone, knone, knone); 		Matte(dest, src1,  dest, opacity/100, knone); end if;if shapePreview == 1; 		frameWidth *= zoomfactor;	image aspectBuffer[w][h * aspectOf(dest)];		color frameTempColor	frameOpacity *= 255/100	frameTempColor = {255, frameOpacity, frameOpacity, frameOpacity};	ChannelFill(aspectBuffer, 255, 0, 0, 0);			//fills aspectBuffer with empty pixels	ChannelFill(xbuffer, 255, 0, 0, 0);					//fills xbuffer with empty pixels	for i = 0 to 3		ovalRect[i].y *= aspectOf(dest);		SourceRect[i].y *= aspectOf(dest);	next	FrameOval(OvalRect, aspectBuffer, frameTempColor, frameWidth);		//draws the ring into aspectBuffer	BlitRect(aspectBuffer, SourceRect, xbuffer, DestRect)	if frameSoft > 0		image blurbuffer[w][h];				blurbuffer = xbuffer		BlurChannel(blurbuffer, xbuffer, frameSoft * zoomfactor, 0, 1, 0, 0, aspectOf(dest));	end if;	ChannelCopy(xbuffer, xbuffer, kred, knone, knone, knone);	ChannelFill(xbuffer, -1, frameColor.r, frameColor.g, frameColor.b);	Matte(xbuffer, dest, dest, 1, kalpha);end if;