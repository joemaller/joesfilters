//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orgfilter "Joe's Threshold & Posterize";group "Joe's Adjustments";input graySRC, "Gray Source", Popup, 3, "Full Color (Posterize)", "Gray (Average)", "Luma", "Red Channel","Green Channel","Blue Channel"input threshold, "Threshold", slider, 127, 1, 254 detent 128;input steps, "Steps", slider, 2, 2, 255input preblur, "Pre Blur", Slider, 0, 0, 150 ramp 93;input postblur, "Post Blur", Slider, 0, 0, 150 ramp 93;input fgcolor, "Foreground", Color, 255, 255, 255, 255;input bgcolor, "Background", Color, 255, 0, 0, 0;input bgTrans, "Transparent Color:", RadioGroup, 2, "Foreground", "Background";input bgOpacity, "Opacity", Slider, 100, 0, 100;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware");ProducesAlphacodeexposedbackground=1float i, j, w, h, adjKey[256], stepup, stepdown, colorSpace, desat[3][3], offset0[3], zoomfactor;colorSpace = GetPixelFormat(dest);			//store this for final conversion at the enddimensionsOf(Dest, w, h);image xbuffer[w][h];zoomfactor = w/720;dest = src1; if graySRC == 3;	if GetPixelFormat(dest) != kFormatYUV219;		ConvertImage(dest, dest, kFormatYUV219);		setpixelformat(xbuffer, kFormatYUV219);	end if	else		if GetPixelFormat(dest) != kFormatRGB219;		ConvertImage(dest, dest, kFormatRGB219);		setpixelformat(xbuffer, kFormatRGB219);	end ifend if// all transforms need to use dest instead of SRC1, SRC1 is offlimits because it's color space is unknown// every gray conversion will copy b/w image to xbuffer's alpha channelif graySRC == 1;			//full color	xbuffer = dest;	else if graySRC == 2;		//average	xbuffer=dest	desat += 0.33	//sets the desaturation matrix to output all channels at 1/3	colorTransform(xbuffer, dest, desat, offset0, offset0);	channelcopy(dest, xbuffer, kred, kred, kred, kred);	else if graySRC == 3; 	//luma	channelcopy(dest, xbuffer, kred, kred, kred, kred);else if graySRC == 4; 	//red		channelcopy(dest, xbuffer, kred, kred, kred, kred);	else if graySRC == 5; 	//green		channelcopy(dest, xbuffer, kgreen, kgreen, kgreen, kgreen);	else if graySRC == 6; 	//blue		channelcopy(dest, xbuffer, kblue, kblue, kblue, kblue);end if	if preblur > 0;	dest = xbuffer;	Blur(dest, xbuffer, preblur * zoomfactor, aspectof(dest));	end iffor i = threshold to 255	adjKey[i] = 1;	//sets all adjKey values above the threshold point to 1next;if steps > 2;	stepdown = threshold - integer(steps/2);	//could have also added steps mod 2 to integer(steps/2)	stepup = stepdown  + steps;		if stepup > 255		// steps range is too wide, need to compress to fit		stepdown += stepup - 255;	// subtracts from the bottom the difference between the desired top and the actual top		stepup = 255;				// sets the top to 255		steps = stepup - stepdown;	// resets the step value to match the output range	end if		if stepdown < 0;		// steps range is too wide, need to compress to fit		stepup += stepdown	//stepdown is less than zero, adding a negative number reduces stepup		stepdown = 0;				steps = stepup - stepdown;	end if	for i = stepdown to stepup		adjKey[i] = (i- stepdown)/steps;	next;end if;if graySRC == 1; 	levelMap(xbuffer, dest, LinearRamp, adjKey, adjKey, adjKey);else;	// graySRC anything but 1	levelMap(xbuffer, dest, adjKey, LinearRamp, LinearRamp, LinearRamp);	xbuffer = dest;	if (graySRC == 3) 		ConvertImage(xbuffer, xbuffer, kFormatRGB219);		ConvertImage(dest, dest, kFormatRGB219);	end if	if bgTrans == 1		InvertChannel(dest, xbuffer, 1, 0, 0, 0); 		channelfill(xbuffer, -1, bgcolor.r, bgcolor.g, bgcolor.b);	// fill around the new alpha channel		channelfill(dest, bgOpacity/100 * 255, fgcolor.r, fgcolor.g, fgcolor.b);	// fill with the background color		matte(xbuffer, dest, dest, 1, kalpha);	else if bgTrans == 2		channelfill(xbuffer, -1, fgcolor.r, fgcolor.g, fgcolor.b);	// fill around the new alpha channel		channelfill(dest, bgOpacity/100 * 255, bgcolor.r, bgcolor.g, bgcolor.b);	// fill with the background color		matte(xbuffer, dest, dest, 1, kalpha);	end ifend if;	if (graySRC != 1)	// restore alpha	image xbuffer2[w][h]	channelcopy(dest, xbuffer, kalpha, kalpha, kalpha, kalpha);	if (GetPixelFormat(src1) != kFormatRGB219) 		ConvertImage(src1, xbuffer2, kFormatRGB219);		channelcopy(xbuffer2, xbuffer2, kalpha, kalpha, kalpha, kalpha);	end if	multiply(xbuffer2, xbuffer, xbuffer, 1, knone);	channelcopy(xbuffer, dest, kred, knone, knone, knone);end ifif postblur > 0	Blur(dest, xbuffer, postblur * zoomfactor, aspectof(dest))	dest = xbuffer;end ifif GetPixelFormat(dest) != colorSpace;	//using colorspace makes this change back to whatever it started as	ConvertImage(dest, dest, colorSpace);end if