//                         v3.5 //	                  //	   wvwwvwvww    //	   \                  /  //	     \______/  //	                          	//       Joe's Filters     //   for Final Cut Pro // (C) 2002 Joe Maller// http://www.joesfilters.com// http://www.fxscriptreference.orggenerator "Joe's Shapes";group "Joe's Generators";input shapelabel, "Shape", label, "";input ShapeWidth, "Width", Slider, 200, 1, 1000 ramp 80;input ShapeHeight, "Height", Slider, 200, 1, 1000 ramp 80;input ShapeScale, "Scale", Slider, 100, 1, 1000 ramp 80;input origin, "Origin", point, 0, 0;input numSides, "Sides", Slider, 4, 3, 20 ramp 75 detent 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20;input ShapeAngle, "Angle", Angle, 0, -360, 360;input filllabel, "Fill", label, "";input fillShape, "Fill Shape", checkbox, 1;input fillColor, "Fill Color", color, 255, 235, 128, 0;input MaskBlur, "Fill Softness", Slider, 0, 0, 500 ramp 92;input shapeOpacity, "Fill Opacity", slider, 100, 0, 100;input SpotInvert, "Fill Frame", checkbox, 0;input borderlabel, "Border", label, "";input drawborder, "Border Shape", checkbox, 1;input frameColor, "Border Color", color, 255, 0, 180, 150;input frameWidth, "Border Width", slider, 8, 1, 100 ramp 50;input frameSoft, "Border Softness", slider, 0, 0, 50 ramp 80;input frameOpacity, "Border Opacity", slider, 100, 0, 100;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";ProducesAlphaAlphaType(kalpha);InformationFlag("hasfields")codeexposedbackground = 1;float h, w, i, angleFix;point ShapeCorners[numSides];dimensionsof(dest, w, h);image xbuffer[w][h];float zoomfactor; zoomfactor = w/720	angleFix = (numSides == 4 || numSides == 6 || numSides == 8) ? 360/numsides/2 : 0			// corrects the rotation of squares, hexagons and octagons, which I prefer flat-side toporigin.x *= w;origin.y *= h;for i = 1 to numSides;	ShapeCorners[i-1].x = origin.x + ShapeScale/100 * ShapeWidth/2 * cos(360/numSides * i -90 - angleFix) * zoomfactor;	ShapeCorners[i-1].y = origin.y + ShapeScale/100 * ShapeHeight/2 * sin(360/numSides * i -90 - angleFix) * zoomfactor / aspectOf(dest);next;Rotate(ShapeCorners, origin, ShapeAngle, aspectOf(dest));if (fillshape)	FillPoly(ShapeCorners, dest, kWhite);		if MaskBlur > 0;		Blur(dest, xbuffer, MaskBlur * zoomfactor, aspectof(dest));	else		xbuffer = dest;	end if;		ChannelFill(dest, 255, fillColor.r, fillColor.g, fillColor.b);	ChannelCopy(xbuffer, dest, kred, knone, knone, knone);		if SpotInvert == 1		InvertChannel(dest, dest, 1, 0, 0, 0)	end if		ChannelMultiply(dest, dest, shapeOpacity/100, 1, 1, 1)else	ChannelFill(dest, 0, frameColor.r, frameColor.g, frameColor.b);	// to prevent color halos when no shape fillend ifif (drawborder == 1 || frameOpacity == 0 ) 	frameWidth *= zoomfactor;	point sourceRect[4], destRect[4];	color frameTempColor	frameOpacity *= 255/100	frameTempColor = {255, frameOpacity, frameOpacity, frameOpacity};		image aspectBuffer[w][h * aspectOf(dest)];		ChannelFill(aspectBuffer, 255, 0, 0, 0);			//fills scalebuffer with empty pixels	ChannelFill(xbuffer, 255, 0, 0, 0);					//fills xbuffer with empty pixels	for i = 0 to (numSides - 1)		ShapeCorners[i].y *= aspectOf(dest);	next		FramePoly(ShapeCorners, aspectBuffer, frameTempColor, frameWidth);	boundsOf(aspectBuffer, sourceRect);	boundsOf(dest, destRect);	BlitRect(aspectBuffer, SourceRect, xbuffer, DestRect);	if frameSoft > 0		image blurbuffer[w][h];				blurbuffer = xbuffer		BlurChannel(blurbuffer, xbuffer, frameSoft * zoomfactor, 0, 1, 0, 0, aspectOf(dest));	end if;	ChannelCopy(xbuffer, xbuffer, kred, knone, knone, knone);	ChannelFill(xbuffer, -1, frameColor.r, frameColor.g, frameColor.b);		 Matte(xbuffer, dest, dest, 1, kalpha);end if;