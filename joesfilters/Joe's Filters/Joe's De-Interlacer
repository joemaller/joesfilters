//                       v5.0 
//	                  
//	     wvwwvwvww    
//	     \                /  
//	       \______/  
//	                          	
//       Joe's Filters     
//	 www.joesfilters.com


// (C) 2001-2004 Joe Maller
// http://www.joesfilters.com
// http://www.fxscriptreference.org


filter "Joe's De-Interlacer";
group "BETA";




input label0, "De-Interlace", label, "";
input FieldPicker, "Field", RadioGroup, 1, "First", "Second";
input fieldDominance, "Field Dominance", popup, 2, "Upper Field First", "Lower Field First";
input FieldMethod, "Method", popup, 1, "Fast Interpolate", "Exact Interpolate", "Field Double";

//input xclip1, "xClip1", Clip;

input label1, "Motion Differencing", label, "";

input motiondiff, "Motion Differencing", popup, 3, "None", "Single Frame", "Surrounding Fields", "Surrounding Frames";


input UPDOWN, "UPDOWN", checkbox, 1;
input showSources, "Show Sources", checkbox, 1;
input showchannels, "Show Channels", checkbox, 0;
input showcolors, "Show Colors", checkbox, 1;
//input fakeBlur, "fakeBlur", checkbox, 0;

//input AN, "AN", angle, 0, -360, 360;
//input ORI, "OR", slider, 0, 0, 5;


//input RGBorYUV, "Difference Using", popup, 2, "RGB", "Luma";

input maskSpread, "Mask Smoothing", slider, 0, -10, 10;

input threshold, "Threshold", slider, 8, 1, 254;
input steps, "Steps", slider, 1, 0, 255;
input soften, "Soften", slider, 2.5, 0, 10;

input label2, "Mask Check", label, "";
input showMask, "View", popup, 1, "Merged Output", "Motion Mask", "Colorize Motion";
input maskcolor, "Mask Color", color, 255, 128, 0, 255;
input maskopacity, "Color Opacity", slider, 60, 0, 100 label "%";

input label3, "Fade With Original", label, "";
input opacity, "Opacity", slider, 100, 0, 100;

input title, "Joe's Filters", Label,"";
input title1, "www.joesfilters.com", Label,"";


fullframe

ProducesAlpha


//InformationFlag("dontEraseDest")

float CLIPDUR, CLIPOFFSET;


code




// INCLUDE "floor.fxscript"  vNew

on floor(value _x)	// simple function to round towards negative infinity
	return( ((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x));
end


// END "floor.fxscript"



// INCLUDE "ceil.fxscript"  v1.2

on ceil(value _x)	// simple function to round towards positive infinity
	return( ((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x));
end

// END "ceil.fxscript"



// INCLUDE "round.fxscript"  v1.1

on round(value _x, value _precision)	// rounding function with decimal precision	
	_x *= power(10, _precision)
	
	if (_x > 0) 
		_x = (_x - integer(_x)  >= 0.5) ? _x = ceil(_x) : floor(_x);
	else
		_x = (_x - integer(_x)  <= -0.5) ? _x = floor(_x) : ceil(_x);
	end if

	return _x/(power(10, _precision));
end


// END "round.fxscript"



// INCLUDE "DeInterlace.fxscript"  v1.1

on DeInterlace(image _src, image _dest, value _field, value _method)
	// field:
	// 0 = top field, 1 = bottom field
	// method:
	// 1 = DeInterlaceFast
	// 2 = DeInterlaceInterpolate
	// 3 = field double
		
	if (_method == 1)
		DeInterlaceFast(_src, _dest, _field);
	else if (_method == 2)
		DeInterlaceInterpolate(_src, _dest, _field);
	else if (_method == 3)
		FieldDouble(_src, _dest, _field);
	end if
end



// END "DeInterlace.fxscript"



// INCLUDE "DeInterlaceInterpolate.fxscript"  v1.1

on DeInterlaceInterpolate(image _srcIMG, image _destIMG, value _field)
	// 0 = top field, 1 = bottom field
	
	float _i, _j;
	point _r1[4], _r2[4];
	
	BoundsOf(_srcIMG, _r1);
	
	image _halfIMG[_r1[1].x - _r1[0].x][(_r1[3].y - _r1[0].y) / 2];
	BoundsOf(_halfIMG, _r2);

	_i = _r2[0].y;

	for _j = _r1[0].y to _r1[3].y step 2
			
		_r1[0].y = _j + _field;
		_r1[1].y = _j + _field;
		_r1[2].y = _j + 1 + _field;
		_r1[3].y = _j + 1 + _field;
					
		_r2[0].y = _i;	// j starts at the topmost row of pixels in _halfIMG and counts up
		_r2[1].y = _i;	
		_r2[2].y = _i + 1;
		_r2[3].y = _i + 1;		

		_i++;

		BlitRect(_srcIMG, _r1, _halfIMG, _r2);
		
	next;
	
	boundsOf(_halfIMG, _r1);
	boundsOf(_destIMG, _r2);
	
	for _j = 0 to 3
		_r2[_j].y += _field; // correct for field bouncing
	next;
	
	BlitRect(_halfIMG, _r1, _destIMG, _r2);
	
end



// END "DeInterlaceInterpolate.fxscript"





// INCLUDE "DeInterlaceFast.fxscript"  v1.5

on DeInterlaceFast(image _srcIMG, image _destIMG, value _field)
	
	// _srcIMG : source image
	// _destIMG : destination image
	// _field : 0 = top field, 1 = bottom field

	// this might fail at some future time if the scaling method in FCP changes

	if (_field != 0 && _field != 1)
		ErrorReporter(dest, "_field must be a boolean");
		return;
	end if	
		
	float _j;
	point _r1[4], _r2[4];
	BoundsOf(_srcIMG, _r1);
	
	if (_field) // second field, shift box down
		_r1[0].y += 1;	// shift top row down
		_r1[1].y += 1;
		if ((_r1[3].y - _r1[0].y) & 1) 	// frame height needs to be even
			_r1[2].y += 1;			// shift bottom down one row
			_r1[3].y += 1;
		end if

	else // first field
		if ((_r1[3].y - _r1[0].y) & 1) // odd frame height
			_r1[2].y -= 1; // odd frame height, trim one row off of bottom
			_r1[3].y -= 1;
		end if
	end if
	image _halfIMG[_r1[1].x - _r1[0].x][(_r1[3].y - _r1[0].y) /2];
	BoundsOf(_halfIMG, _r2);
	BlitRect(_srcIMG, _r1, _halfIMG, _r2); // smash blit (isolates fields)
	
	makeRect(_r2, _r2[0].x, _r2[0].y - _field/2, _r2[1].x - _r2[0].x, _r2[3].y - _r2[0].y)	// corrects for  field bouncing
	BoundsOf(_destIMG, _r1);
	BlitRect(_halfIMG, _r2, _destIMG, _r1);

end

// END "DeInterlaceFast.fxscript"





// INCLUDE "FieldDouble.fxscript"  v1.1



on FieldDouble(image _srcIMG, image _destIMG, value _field)
	// 0 = top field, 1 = bottom field

	float _i, _j, _k;
	point _r1[4], _r2[4];
	
	BoundsOf(_srcIMG, _r1);
	
	image _tempIMG[_r1[1].x - _r1[0].x][(_r1[3].y - _r1[0].y)];

	_r2 = _r1;
	_r2[2].y = _r2[1].y + 1; 
	_r2[3].y = _r2[0].y + 1;


	for _j = _r1[0].y to _r1[3].y step 2
			
		_r1[0].y = _j + _field;
		_r1[1].y = _j + _field;
		_r1[2].y = _j + 1 + _field;
		_r1[3].y = _j + 1 + _field;

		for _k = 0 to 1
			BlitRect(_srcIMG, _r1, _tempIMG, _r2);
			
			for _i = 0 to 3
				_r2[_i].y += 1;
			next;
		next;
		
	next;
	
	boundsOf(_tempIMG, _r1);
	boundsOf(_destIMG, _r2);
	
	for _j = 0 to 3
		_r1[_j].y += _field ^1; // correct for field bouncing
	next;

	BlitRect(_tempIMG, _r1, _destIMG, _r2);
	
end



// END "FieldDouble.fxscript"



// INCLUDE "makeThresholdMapBez.fxscript"  v1.1

on makeThresholdMapBez(float _lmap, value _th, value _steps, value _mapLength)
		// a fast thresholding function using BezToLevelMap instead of for:next loops
		// _th is the point to thrreshold around, _steps are the number of grays around _th
		// mapLength is 255 for 8-bit maps
		
	point _p1, _p2;
	
	float _top, _bottom;
	
	if (_th - _steps/2 < 0)
		_steps = _th * 2;
	else if (_th + _steps/2 > _mapLength)
		_steps = (_mapLength - _th) * 2;
	end if
	
	if (_th & 1 == 0)	// even
		_p1 = {floor(_th - _steps/2)/_mapLength, 0};		
		_p2 = {floor(_th + _steps/2)/_mapLength, 1};		
	else // _th is odd
		_p1 = {ceil(_th - _steps/2)/_mapLength, 0};		
		_p2 = {ceil(_th + _steps/2)/_mapLength, 1};		
	end if

	BezToLevelMap(_lmap, _p1, _p1, _p2, _p2, 0, _mapLength, TRUE);

end



// END "makeThresholdMapBez.fxscript"



// INCLUDE "BlurChannelInPlace.fxscript"  vNew

on 	BlurChannelInPlace(image _src, image _dest, value _radius, value _A, value _R, value _G, value _B, value _aspect)
	
	// _src, _dest : input/output image buffers
	// _radius : blur radius
	// _A, _R, _G, _B : boolean switches telling whether to blur the channel or not
	// _aspect : aspect ratio the blur will be processed against
		
	if (_radius > 0)
		float _w, _h;
		dimensionsOf(_dest, _w, _h);
		image _temp[_w][_h];

		if (_A + _R + _G + _B < 4)
			_temp = _src;
		end if
		
		BlurChannel(_src, _temp, _radius, _A, _R, _G, _B, _aspect);	

		_dest = _temp;
	else
		_dest = _src;
	end if
end

// END "BlurChannelInPlace.fxscript"



// INCLUDE "DifferenceMask.fxscript"  v1.1

on DifferenceMask(image _src1, image _src2, image _dest, value _threshold, value _steps, value _softness)
	
	// dependencies:
	//			makeThresholdMapBez
	//			channelcopyfit

	// _src1, src2 : images to compare
	// _dest : destination image buffer, results will replace this image's alpha channel
	// _threshold : Threshold break for difference mask
	// _steps : number of steps around threshold point
	// _softness : spread of the difference mask before thresholding.
	
	// compares two images and generates a mask based on differences between the two
	// the resulting mask will replace whatever alpha channel is in _dest
		
	float _diffmap[256];
	makeThresholdMapBez(_diffmap, _threshold, _steps, 255)	

	point _src1Box[4], _src2Box[4];
	boundsOf(_src1, _src1Box);
	boundsOf(_src2, _src2Box);
	
	if (_src1Box[2].x * _src1Box[2].y == _src2Box[2].x * _src2Box[2].y)	// _src1 and _src2 should be the same size, should be most common

		image _temp1[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y],  _temp2[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y];
		
		_temp1 = _src1;
		_temp2 = _src2;
		
	else if (_src1Box[2].x * _src1Box[2].y > _src2Box[2].x * _src2Box[2].y)	// _src1 has more pixels, scale _src1 down to match _src2 (bias for speed)
		image _temp1[_src2Box[1].x - _src2Box[0].x][_src2Box[3].y - _src2Box[0].y],  _temp2[_src2Box[1].x - _src2Box[0].x][_src2Box[3].y - _src2Box[0].y];

		_temp2 = _src2;
		blitRect(_src1, _src1Box, _temp1, _src2Box);

	else	// _src1 has fewer pixels than _src2, scale _src2 down to match

		image _temp1[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y],  _temp2[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y];
	
		_temp1 = _src1;
		blitRect(_src2, _src2Box, _temp2, _src1Box);

	end if
	
	Difference(_temp1, _temp2, _temp1, kalpha);	// setting targets up beforehand is faster
	BlurChannel(_temp1, _temp2, _softness, 1,1,1,1, aspectOf(_dest));
	LevelMap(_temp2, _temp2, linearRamp, linearRamp, _diffmap, linearRamp);
	channelcopyfit(_temp2, _dest, kgreen, knone, knone, knone);
end

// END "DifferenceMask.fxscript"



// INCLUDE "NumReporter.fxscript"  v1.1

on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)
	
	float rw, rh, ra, rd, rzoom;
	string reporter;
	color fontcolor;
	
	DimensionsOf(_destIMG, rw, rh);
	rzoom = rw/720;
	
	fontcolor = {255,235,235,235};
	settextfont("verdana");
	setTextstyle(kbold);
	setTextjustify(kcenterjustify);
	setTextSize(_fontsize * rzoom);
													
	NumToString(_data, reporter, _numberformat);
	reporter = _label + " = " + reporter;
	DrawString(reporter, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));

end


// END "NumReporter.fxscript"




// INCLUDE "ChannelCopyFit.fxscript"  v1.4

on ChannelCopyFit(image _src, image _dest, value _A, value _R, value _G, value _B)
	// a combination of channelcopy and blitrect, scales any specified channel to fit the target
	// specifically for cases where a channel source is not the same size as the channel destination
	// _A, _R, _G & _B work just like Channelcopy and are of the set {kalpha, kred, kgreen, kblue}
	// This is meant to be a more versatile drop-in replacement for ChannelCopy
	
	point _srcBox[4], _destBox[4];
	boundsOf(_src, _srcBox);
	boundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		// sizes are equal, normal channelcopy...
		channelCopy(_src, _dest, _A, _R, _G, _B);

	else	// sizes are unequal, do blit then channel
		
		
		//		check for size differences
		// 		do channelcopy on smaller image 
		// 		is still faster to down-blit the bigger image first since channelcopy is costly
		
		//if (_srcBox[2].x * _srcBox[2].y > _destBox[2].x * _destBox[2].y)	// _src is larger than _dest
		if (true)
			image _temp[_destBox[1].x - _destBox[0].x][_destBox[3].y - _destBox[0].y]; // create second dest-sized image buffer
			blitRect(_src, _srcBox, _temp, _destBox);
			channelCopy(_temp, _dest, _A, _R, _G, _B);
		
		else // _dest is larger than _src
			image _temp[_srcBox[1].x - _srcBox[0].x][_srcBox[3].y - _srcBox[0].y]; // create second src-sized image buffer
			blitRect(_dest, _destBox, _temp, _srcBox);
			channelCopy(_src, _temp, _A, _R, _G, _B);
			blitRect(_temp, _srcBox, _dest, _destBox);
		
		end if
	end if
end

// END "ChannelCopyFit.fxscript"



// INCLUDE "getField.fxscript"  v1.3

on getField(clip _clip1, value _offset, image _dest, value _nativeW, value _nativeH, value _field);
	// getField(clip, frame, dest, 720, 480, 1);
	// replacement for GetVideo which returns a single field of interlaced video
	// basic getVideo call plus dinmensions and field selection
	// field is 0 or 1 to match deinterlace functions
	
	// getvideo into half-height buffers appears to return only the upper field (line 0)
	// that means de-intelacing can be skipped for matching fields to save processing
	
	if (_field < 0 || _field > 1)
		ErrorReporter(dest, "_field value out of range");
		return;
	end if
	
	
	if (_field == 0)
		image _half[_nativeW][_nativeH/2];
		point _halfBox[4], _destBox[4];
		boundsOf(_half, _halfBox);
		boundsOf(_dest, _destBox);
		
		if (_halfBox[0] == _destBox[0] && _halfBox[2] == _destBox[2])	// _half is the same size as _dest, skip a blit
		
			getVideo(_clip1, _offset, _dest);

		else		// _half and _dest are different sizes, use blitRect
				
			getVideo(_clip1, _offset, _half);
			blitRect(_half, _halfBox, _dest, _destBox);
		
		end if
		
			
	else // _field == 1
		image _full[_nativeW][_nativeH];
		getVideo(_clip1, _offset, _full);
		DeInterlaceFast(_full, _dest, _field);
	end if
	
end	// end getField



// END "getField.fxscript"



// INCLUDE "ErrorReporter.fxscript"  v1.1

on ErrorReporter(image _dest, string _errorMsg)
	float _w, _h;
	
	dimensionsOf(dest, _w, _h);
	
	settextfont("verdana");
	setTextstyle(kbold);
	setTextjustify(kcenterjustify);
	setTextSize(_w * 0.05);
	
	channelfill(_dest, 255, 255, 125, 0);
	DrawString(_errorMsg, 0, 0, 1.25, _dest, kwhite, aspectof(_dest));

	
	setTextjustify(krightJustify);
	setTextSize(_w * 0.025);
	DrawString("FXScriptReference.org", 0.4 * _w, 0.4 * _h, 1.25, _dest, kwhite, aspectof(_dest));

end // end ErrorHandler


// END "ErrorReporter.fxscript"



// INCLUDE "PtReporter.fxscript"  v1.1

on PtReporter(image _destIMG, point _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)
	
	float rw, rh, ra, rd, rzoom;
	string reporterX, reporterY;
	color fontcolor;
	
	DimensionsOf(_destIMG, rw, rh);
	rzoom = rw/720;
	
	fontcolor = {255,235,235,235};
	settextfont("verdana");
	setTextstyle(kbold);
	setTextjustify(kcenterjustify);
	setTextSize(_fontsize * rzoom);
													
	NumToString(_data.x, reporterX, _numberformat);
	NumToString(_data.y, reporterY, _numberformat);
	reporterX = _label + " = {" + reporterX + "," + reporterY + "}";
	DrawString(reporterX, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));

end


// END "PtReporter.fxscript"




on ChannelView(image _src, image _dest, value _colors)

	// requires PlaceFrame.fxscript
	// _src, _dest : source and destination image buffers
	// _colors : boolean switch to show channels in color

	point _dims, _srcBox[4], _destBox[4];
	dimensionsOf(_dest, _dims.x, _dims.y);
	image _temp[_dims.x][_dims.y];
	
	
	_colors ^= 1;
	boundsOf(_src, _srcBox)
	boundsOf(_dest, _destBox);


	channelfill(_temp, 255, 0, 0, 0);
	_destBox *= 0.5;
	
	
	channelcopy(_src, _temp, knone, kalpha, kalpha, kalpha)
	PlaceFrame(_temp, _dest, _destBox[0], _destBox[2].x * 2, _destBox[2].y * 2, 0, 4)
	
	channelcopy(_src, _temp, knone, kred, kred, kred)
	channelMultiply(_temp, _temp, 1, 1, _colors, _colors);
	PlaceFrame(_temp, _dest, _destBox[1], _destBox[2].x * 2, _destBox[2].y * 2,  0, 4)
	
	channelcopy(_src, _temp, knone, kgreen, kgreen, kgreen);
	channelMultiply(_temp, _temp, 1, _colors, 1, _colors);
	PlaceFrame(_temp, _dest, _destBox[3], _destBox[2].x * 2, _destBox[2].y * 2,  0, 4)
	
	channelcopy(_src, _temp, knone, kblue, kblue, kblue);
	channelMultiply(_temp, _temp, 1, _colors, _colors, 1);
	PlaceFrame(_temp, _dest, _destBox[2], _destBox[2].x * 2, _destBox[2].y * 2,  0, 4)

end



on ColorRampImage(image _img, color _fg, color _bg, value _thr, value _steps)

		// can convert an image into a two-color ramp in place with thresholding
		

	float _w, _h, _adj[256];
	dimensionsOf(_img, _w, _h);
	
	image _temp[_w][_h];
	
	Desaturate(_img, _img);
	channelcopy(_img, _img, kgreen, knone, knone, knone)


	makeThresholdMapBez(_adj, _thr, _steps, 255)	
	LevelMap(_img, _temp, _adj, linearRamp, linearRamp, linearRamp);
	
	channelfill(_img, _bg.a, _bg.r, _bg.g, _bg.b);
	channelfill(_temp, -1, _fg.r, _fg.g, _fg.b);
	matte(_temp, _img, _img, 1, kalpha);

end



// INCLUDE "PlaceFrame.fxscript"  vNew

on PlaceFrame(image _src, image _dest, point _originPt, value _frameWidth, value _frameHeight, value _angle, value _orientation)
		
		// _src : source image to copy from
		// _dest : destination image buffer
		// _originPt: point in destination buffer where the fframe will be drawn
		// _frameWidth: width of the output frame
		// _frameHeight: height of the output frame
		// _angle: rotation angle of rotated frame, around _originPt
		// _orientation:  0-3 = destination rectangle corners, 4 = center
		
	if (_orientation < 0 || _orientation > 4)
		ErrorReporter(dest, "_orientation value out of range (0-4)");
		return;
	end if
	
	if (_orientation - integer(_orientation) > 0)
		ErrorReporter(dest, "_orientation must be an integer");
		return;
	end if
	
		
	point _srcBox[4], _destBox[4], _rotateCenter;
	boundsOf(_src, _srcBox);
	
	if (_orientation == 0)	
		MakeRect(_destBox, _originPt.x,  _originPt.y, _frameWidth, _frameHeight);
		_rotateCenter = _destBox[0];

	else if (_orientation == 1)
		MakeRect(_destBox, _originPt.x - _frameWidth,  _originPt.y, _frameWidth, _frameHeight);
		_rotateCenter = _destBox[1];

	else if (_orientation == 2)
		MakeRect(_destBox, _originPt.x - _frameWidth,  _originPt.y - _frameHeight, _frameWidth, _frameHeight);
		_rotateCenter = _destBox[2];

	else if (_orientation == 3)
		MakeRect(_destBox, _originPt.x,  _originPt.y- _frameHeight, _frameWidth, _frameHeight);
		_rotateCenter = _destBox[3];
		
	else if (_orientation == 4)
		MakeRect(_destBox, _originPt.x - _frameWidth/2,  _originPt.y - _frameHeight/2, _frameWidth, _frameHeight);
		_rotateCenter = _originPt;
	end if
	
	Rotate(_destBox, _rotateCenter, _angle, aspectOf(_dest));
	blitRect(_src, _srcBox, _dest, _destBox);
	
	// note 7-31-04: may want to add something to report output rectangle for easier tiling...

end


// END "PlaceFrame.fxscript"
















// **** Set Definitions

exposedbackground = 1;



// **** Correct Input Values

fieldPicker -= 1; //make this either 0 or 1
fieldDominance -= 1;








float h, w, theField;


theField = fieldPicker ^ fieldDominance; // sets the spacial field to retrieve

dimensionsOf(dest, w, h);
image xbuffer[w][h];				//full size buffer
image xbuffer2[w][h];				//full size buffer

image halfbuffer[w][h/2];
image halfbuffer2[w][h/2];	


DeInterlace(src1, dest, theField, FieldMethod); // primary deinterlace, 
	
	
	maskSpread += 10;
	maskSpread /= 2;
	
	threshold = maskSpread * 0.8 + 4;
//	soften = (12 - threshold) /2
	soften = threshold/4
	

if (CLIPDUR == kundefined); // check for cached data
	getLimits(clip1, CLIPDUR, CLIPOFFSET);
end if;

if (CLIPDUR > 0)
	
	if (motiondiff ==2)	// single frame, diff fields
		DeInterlaceFast(src1, halfbuffer, theField ^ 1);
		DifferenceMask(halfbuffer, dest, dest, threshold, steps, soften );	//  reuses pre-deinterlaced field
	
	else if (motiondiff == 3)	// surrounding fields
		
	//	getField(clip1, -CLIPOFFSET + frame + ((fieldPicker ^ fieldDominance) * 2 - 1), halfbuffer, w, h, theField ^ 1);
		getField(clip1, -CLIPOFFSET + frame + ((theField ^ 1) * 2 - 1), halfbuffer, w, h, theField ^ 1);
		DeInterlaceFast(src1, halfbuffer2, theField ^ 1);

		DifferenceMask(halfbuffer, halfbuffer2, dest, threshold, steps, soften);
		
	else if (motiondiff == 4) 	// surrounding frames, double-diff now-prev, now-next
		getVideo(clip1, -CLIPOFFSET + frame - 1, xbuffer);
		getVideo(clip1, -CLIPOFFSET + frame + 1, xbuffer2);
		
		DifferenceMask(src1, xbuffer, xbuffer, threshold, steps, soften);
		DifferenceMask(src1, xbuffer2, xbuffer2, threshold, steps, soften);
		add(xbuffer, xbuffer2, xbuffer, 1, kalpha)
		channelcopy(xbuffer, dest, kalpha, knone, knone, knone);
	
	end if			
 	
 	if (showMask == 2) // show mask channel
 		channelcopy(dest, dest, knone, kalpha, kalpha, kalpha);
 		channelfill(dest, 255, -1, -1, -1);
 	else // standard or highlight motion
 		if (showMask == 3)
 			channelfill(dest, -1, maskcolor.r, maskcolor.g, maskcolor.b);
 		end if
 		//if (opacity < 100)
 			//channelmultiply(src1, xbuffer, opacity/100, 1,1,1);
	 	matte(dest, src1, dest, opacity/100, kalpha);
 		//end if
	end if
end if



if (showSources)
	xbuffer = dest;
	point destBox[4];
	boundsOf(dest, destBox);
	destBox[0].y *= 0;
	destBox[0].y -= h * 1/6;
	destBox[0].x += 1/3 * w;
	PlaceFrame(xbuffer, dest, destBox[0], destBox[2].x* 2/3, destBox[2].y* 2/3,  0, 0);
	destBox[0].x -= 1/3 * w;
	PlaceFrame(halfbuffer, dest, destBox[0], destBox[2].x * 2/3, destBox[2].y * 2/3,  0, 0)
	destBox[0].x += 2/3 * w;
	PlaceFrame(halfbuffer2, dest, destBox[0], destBox[2].x * 2/3, destBox[2].y * 2/3,  0, 0)

end if


if (showchannels)
	xbuffer = dest
	ChannelView(xbuffer, dest, showcolors)
end if

//numreporter(dest, threshold, "threshold", kfloat2, 0, 42, 1.25)
//numreporter(dest, soften, "soften", kfloat2, 30, 42, 1.25)
//numreporter(dest, maskSpread, "maskSpread", kfloat2, -30, 42, 1.25)

