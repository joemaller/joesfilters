filter "Joe’s One Color Noise";
group "Joe’s Filters [BETA]";


input noiseFPS, "Noise FPS", slider, 24, 0, 60;

input NoiseAmount, "Amount", slider, 30, 0, 400 ramp 80 detent 100;
input fixedNoise, "Fixed Noise", checkbox, 0

input noiseScale, "Scale Noise", slider, 200, 100, 1000 label "%";
input softnoise, "Blur Noise", slider, 0, 0, 50 ramp 80; 
input noiseAspect, "Noise Aspect", Slider, 1, 0, 2 detent 1;

input noiseColor, "Noise Color", Color, 255, 255, 125, 0;

input ApplyAs, "Mode", Popup, 1, "Normal", "Multiply", "Screen", "Overlay", "Lighten", "Darken", "Add", "Subtract", "Difference", "Bump";
input Opacity, "Opacity", slider, 100, 0, 100;

input dir, "Direction", angle, 10, -360, 360 detent 10
input outset, "outset", slider, 0.25, 0,3;


input jfcopyright, "© Joe’s Filters", Label,"";
input jfurl, "www.joesfilters.com", Label,"";

RenderEachFrameWhenStill
InformationFlag("YUVaware");
producesAlpha

code

exposedBackground=1;




// INCLUDE "RandomNoiseScaled.fxscript" r159

on RandomNoiseScaled(image _dest, value _noise, value _rFloor, value _rCeil, value _gFloor, value _gCeil, value _bFloor, value _bCeil, value _scale, value _blur, value _aspect, value _colorspace)
	// 	_noise is a 0...400 vallue to match Photoshop's controls
	//	_scale is value >100 (there's no point in down-scaling)
	//	_rFloor, _rCeil, _g..., _b... are 0-255 values
	// 	_colorspace is 1-3 to match the numeric equivalents for the color space constants: kFormatRGB255=1, kFormatRGB219=2, kFormatYUV219=3;
	float _w, _h;
	point _box0[4], _box1[4];

	dimensionsOf(_dest, _w, _h);
	image _img0[(_w-1) / _scale * (_aspect > 1 ? (2 - _aspect): 1) + 1][(_h-1) / _scale * (_aspect < 1 ? _aspect : 1) + 1];
	ConvertImage(_img0, _img0, _colorspace);

	boundsof(_dest, _box0);
	boundsof(_img0, _box1);
	
	RandomNoise(_img0, ((_noise < 100) ? _noise/100 * 255 : 255), ((_noise > 100) ? (_noise-100)/300 * 255 : 0), _rFloor, _rCeil, _gFloor, _gCeil, _bFloor, _bCeil, 1)

	if (_blur > 0);
		dimensionsOf(_img0, _w, _h);
		image _blurIMG[_w][_h];	
		ConvertImage(_img0, _img0, _colorspace);
		
		_blurIMG = _img0;
		blurChannel(_img0, _blurIMG, _blur / _scale, 1, 1, 1, 1, 1);
		blitRect(_blurIMG, _box1, _dest, _box0);
	else
		blitRect(_img0, _box1, _dest, _box0);
	end if;

end 

// END "RandomNoiseScaled.fxscript"



// INCLUDE "RandomSeedFPS.fxscript" r158

float trueFPS = fps * (fieldprocessing+1);		// interlace-corrected FPS

on RandomSeedFPS(value _fakeFPS, value _baseFPS, value _baseDuration, value _baseRatio)
	// this sets randomseed based on the completion of the clip calculated against the fakeFPS
	// this is accomplished by recreating ratio using the fake values
	// first determine a new fakeDuration, this is from the ration of fakeFPS/realFPS * duration
	// next calculate a fake frame number based
	// in most cases _baseDuration and _baseRatio are just duration and ratio, but better to keep them malleable

	if (_fakeFPS > 0)
		float _fpsRatio, _fakeDuration, _fakeRatio, _fakeFrame;
		_fpsRatio = _fakeFPS/_baseFPS; // find output fps as percentage of _baseFPS
		_fakeDuration = integer(_fpsRatio * duration);
		_fakeFrame = integer(_baseRatio * _fakeDuration + 1)
		_fakeRatio = _fakeFrame/_fakeDuration;
		randomseed(_fakeRatio); // use fps modified ratio for RandomSeed
	else
		randomseed(0);
	end if
end

// END "RandomSeedFPS.fxscript"




// INCLUDE "RGBtoYUVcolor.fxscript" r160

on RGBtoYUVcolor(color _rgbColor)
	color _temp;
	_temp = _rgbColor
	_rgbColor.r = _temp.r * 0.299 + _temp.g * 0.587 + _temp.b * 0.114 
	_rgbColor.g = _temp.r * -0.169 + _temp.g * -0.332 + _temp.b * 0.500 + 128; 
	_rgbColor.b = _temp.r * 0.500 + _temp.g * -0.419 + _temp.b * -0.0813 + 128;
end 

// END "RGBtoYUVcolor.fxscript"

RGBtoYUVcolor(noiseColor);

RandomNoiseScaled(dest, NoiseAmount, noiseColor.r, noiseColor.r, noiseColor.g, noiseColor.g, noiseColor.b, noiseColor.b, noiseScale/100, softnoise, noiseAspect, 3);

if ApplyAs == 1; Matte(dest, src1, dest, opacity/100, kalpha); end if
if ApplyAs == 2; Multiply(src1, dest, dest, opacity/100, kalpha); end if
if ApplyAs == 3; Screen(src1, dest, dest, opacity/100, kalpha); end if
if ApplyAs == 4; Overlay(src1, dest, dest, opacity/100, kalpha); end if
if ApplyAs == 5; Lighten(src1, dest, dest, opacity/100, kalpha); end if
if ApplyAs == 6; Darken(src1, dest, dest, opacity/100, kalpha); end if
if ApplyAs == 7; add(src1, dest, dest, opacity/100, kalpha); end if;
if ApplyAs == 8; 
		subtract(src1, dest, dest, opacity/100, kalpha);
		ChannelCopy(src1, dest, kalpha, knone, knone, knone); 
 end if;
if ApplyAs == 9; 
		Difference(src1, dest, dest, kalpha); 
		ChannelCopy(src1, dest, kalpha, knone, knone, knone); 
		Matte(dest, src1,  dest, opacity/100, knone); 
end if;
