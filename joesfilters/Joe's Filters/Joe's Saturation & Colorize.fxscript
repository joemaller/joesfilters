filter "Joe's Saturation & Colorize";group "Joe's Filters [BETA]";//	input hue, "Hue Angle", Angle, 60, -360, 360 input desat, "Saturation", Slider, 100, 0, 1000 ramp 93 label "%" detent 100input colorize, "Colorize", checkbox, 1;input targetColor, "Target", Color, 255, 0, 0, 255;input colorFrom, "Color From", RadioGroup, 1, "Color", "Angle";input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware");InformationFlag("dontEraseDest");code// INCLUDE "basic_math.fxscript" r128on max(value _a, value _b); return (_a > _b) ? _a : _b; end on min(value _a, value _b); return (_a < _b) ? _a : _b; end on ceil(value _x); return(((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x)); end on floor(value _x); return(((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x)); end // END "basic_math.fxscript"on NormalizeColorVector(color _c, point3d _p)	if (_c.r + _c.g + _c.b == 0); _p *= 0; _p += 1/sqrt(3); return; end if // do nothing for black input color	float _l;	_l = sqrt(power(_c.r,2) + power(_c.g,2) + power(_c.b,2));	_p = {_c.r, _c.g, _c.b};	_p /= _l;endon normalizeVector3d(point3d _V)	float _l;	_l = sqrt(power(_V.x,2) + power(_V.y,2) + power(_V.z,2));	_V /= _l // transforms _V into a normalized vector, length = 1;end // INCLUDE "NumReporter.fxscript" r124on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);		if (getPixelFormat(_destIMG)==kFormatYUV219)		fontcolor = {255,235,128,128};	else		fontcolor = {255,235,235,235};	end if	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end// END "NumReporter.fxscript"// INCLUDE "pt3dReporter.fxscript" r124on Pt3dReporter(image _destIMG, point3d _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd, rzoom;	string reporterX, reporterY, reporterZ;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,25,0,195};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize * rzoom);														NumToString(_data.x, reporterX, _numberformat);	NumToString(_data.y, reporterY, _numberformat);	NumToString(_data.z, reporterZ, _numberformat);	reporterX = _label + " = {" + reporterX + "," + reporterY + "," + reporterZ + "}";	DrawString(reporterX, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end // END "pt3dReporter.fxscript"on VectorStretch(point3d _v)	_v /= max(_v.x, max(_v.y, _v.z));endon SaturationAndColorizeToTarget(image _src, image _dest, color _target, value _saturation, value _colorize)	// DEPENDENCIES:  NormalizeColorVector, vectorStretch		//	_saturation is a floating point value between 0 and 10	//	_colorize is a boolean	//	_target is the color to target desaturation on.	float _mat[3][3], _colorSpace;	float _rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb, _offset0[3];	//	float _w, _h;	point3d _normedColor;	NormalizeColorVector(_target, _normedColor);	_colorSpace = getPixelFormat(_dest);	if (_colorSpace != kFormatRGB219)		ConvertImage(_src, _src, kFormatRGB219);		SetPixelFormat(_dest, kFormatRGB219);	end if		_offset0 = {0,0,0};	if (_colorize != 1)		//define initial matrix values for straight pass-through		_rr = 1; _rg = 0; _rb = 0;		_gr = 0; _gg = 1; _gb = 0;		_br = 0; _bg = 0; _bb = 1;		_rr -= (_rr - _normedColor.x) * _saturation;		_rg -= (_rg - _normedColor.x) * _saturation; 	_rb -= (_rb - _normedColor.x) * _saturation;		_gr -= (_gr - _normedColor.y) * _saturation;		_gg -= (_gg - _normedColor.y) * _saturation; 	_gb -= (_gb - _normedColor.y) * _saturation;		_br -= (_br - _normedColor.z) * _saturation;		_bg -= (_bg - _normedColor.z) * _saturation; 	_bb -= (_bb - _normedColor.z) * _saturation;		_mat = {_rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb};	else		_normedColor -= 0.5;		_normedColor *= _saturation;		_normedColor += 0.5;		vectorStretch(_normedColor);		if (_saturation > 1); 			_normedColor *= _saturation; 		end if				_mat = {_normedColor.x, 0, 0, 	0, _normedColor.y, 0,		0, 0, _normedColor.z};	end if		colorTransform(_src, _dest, _mat, _offset0, _offset0);		//	_colorSpace = getPixelFormat(_dest);	//	numReporter(_dest, _colorSpace, "post_color", kfloat4, 40, 32, kcenterjustify);	//	numReporter(_dest, c1, "_src colorspace", kfloat4, -50, 32, kcenterjustify);	//	numReporter(_dest, c2, "_dest colorspace", kfloat4, -20, 32, kcenterjustify);	//	numReporter(_dest, c3, "_src->RGB colorspace", kfloat4, 10, 32, kcenterjustify);	//	numReporter(_dest, kFormatYUV219, "kFormatYUV219", kfloat4, 70, 32, kcenterjustify);	//	numReporter(_dest, kFormatRGB219, "kFormatRGB219", kfloat4, 90, 32, kcenterjustify);	//	numReporter(_dest, kFormatRGB255, "kFormatRGB255", kfloat4, 110, 32, kcenterjustify);	//	if (getPixelFormat(_dest) != _colorSpace);	// return the same color space as we started with	//	ConvertImage(_dest, _dest, _colorSpace);	//	end if	//	_normedColor = {_mat[0][0], _mat[0][1], _mat[0][2]};	//	Pt3dReporter(_dest, _normedColor, "red", kfloat4, 0, 40, kcenterjustify);	//		//	_normedColor = {_mat[1][0], _mat[1][1], _mat[1][2]};	//	Pt3dReporter(_dest, _normedColor, "green", kfloat4, 40, 40, kcenterjustify);	//		//	_normedColor = {_mat[2][0], _mat[2][1], _mat[2][2]};	//	Pt3dReporter(_dest, _normedColor, "blue", kfloat4, 80, 40, kcenterjustify);	//		//	numReporter(_dest, _saturation, "_saturation", kfloat4, -50, 32, kcenterjustify);enddesat = (colorize == 1) ? desat/100 : 1 - desat/100;	//makes the desaturate value a decimal value between 0 and 1if (colorFrom == 2)	// convert angle to hue	float rTGT, gTGT, bTGT;	hue = (hue + 360 )mod 360;	if (hue < 120);						//need a range of 0-120 on either side of zero		rTGT = (120 -  hue)/60;	else if (hue > 240);		rTGT = (120 - (abs(hue - 360)))/60;	else 		rTGT = 0;	end if		gTGT = (hue < 240) ? (120 - (abs(hue - 120)))/60 : 0;	bTGT = (hue > 120) ? (120 - (abs(hue - 240)))/60 : 0;	rTGT = (rTGT > 1) ? 1 : rTGT;		//to prevent blowouts during colorization	gTGT = (gTGT > 1) ? 1 : gTGT;	bTGT = (bTGT > 1) ? 1 : bTGT;	if (colorize == 0 && (rTGT + gTGT + bTGT > 1))		//colorize values add up to more than 1		rTGT /= (rTGT + gTGT + bTGT); 		gTGT /= (rTGT + gTGT + bTGT); 		bTGT /= (rTGT + gTGT + bTGT); 	end if	targetColor = {255, rTGT, gTGT, bTGT};			// set targetColor to match the slider valuesend ifSaturationAndColorizeToTarget(src1, dest, targetColor, desat, colorize);