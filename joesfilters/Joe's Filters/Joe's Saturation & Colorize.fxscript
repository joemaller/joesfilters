filter "Joe's Saturation & Colorize";group "Joe's Filters [BETA]";input hue, "Hue Angle", Angle, 0, -360, 360 input desat, "Saturation", Slider, 0, 0, 1000 ramp 93 label "%" detent 100input colorize, "Colorize", checkbox, 0;input targetColor, "Target", Color, 255, 125, 22, 55;input colorFrom, "Color From", RadioGroup, 1, "Color", "Angle";input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware");codeon SaturationAndColorizeToTarget(image _src, image _dest, color _target, value _saturation)	float _w, _h;	DimensionsOf(dest, _w, _h);	image _img0[_w][_h];	point3d _normedColor;	ColorToVector(_target, _normedColor);		float _r, _g, _b, _mat[3][3],_colorSpace;	_colorSpace = getPixelFormat(_src);	if (_colorSpace != kFormatRGB219)		ConvertImage(_src, _img0, kFormatRGB219);	else		_img0 = _src;	end if	if (getPixelFormat(_dest) != kFormatRGB219)		ConvertImage(_dest, _dest, kFormatRGB219);	end if	_r = 0; _g = 1; _b = 2; // used to simplify the matrix assignments instead of having to keep track of the numbers	float _rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb, _offset0[3];	//define initial matrix values for straight pass-through	_rr = 1; _rg = 0; _rb = 0;	_gr = 0; _gg = 1; _gb = 0;	_br = 0; _bg = 0; _bb = 1;   _rr -= (_rr - _normedColor.x) * _saturation;		_rg -= (_rg - _normedColor.x) * _saturation;		_rb -= (_rb - _normedColor.x) * _saturation;   _gr -= (_gr - _normedColor.y) * _saturation;		_gg -= (_gg - _normedColor.y) * _saturation;		_gb -= (_gb - _normedColor.y) * _saturation;   _br -= (_br - _normedColor.z) * _saturation;		_bg -= (_bg - _normedColor.z) * _saturation;		_bb -= (_bb - _normedColor.z) * _saturation;	if (colorize != 1)		_mat = {_rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb};	else		_mat = {_rr, _gg*_saturation/3, _bb*_saturation/3, _rr*_saturation/3, _gg, _bb*_saturation/3, _rr*_saturation/3, _gg*_saturation/3, _bb};	end if		colorTransform(_img0, _dest, _mat, _offset0, _offset0);	//	Pt3dReporter(dest, normColor, "normcolor", kfloat4, 0, 32, kcenterjustify);	if (getPixelFormat(_dest) != _colorSpace)	// return the same color space as we started with		ConvertImage(_dest, _dest, _colorSpace);	end ifendon ColorToVector(color _c, point3d _p)	if (_c.r + _c.g + _c.b == 0); _p *= 0; return; end if // do nothing for black input color	float _l;	_l = sqrt(power(_c.r,2) + power(_c.g,2) + power(_c.b,2));	_p = {_c.r, _c.g, _c.b};	_p /= _l;end// INCLUDE "NumReporter.fxscript" r124on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd, rzoom;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize * rzoom);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end// END "NumReporter.fxscript"// INCLUDE "pt3dReporter.fxscript" r124on Pt3dReporter(image _destIMG, point3d _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd, rzoom;	string reporterX, reporterY, reporterZ;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize * rzoom);														NumToString(_data.x, reporterX, _numberformat);	NumToString(_data.y, reporterY, _numberformat);	NumToString(_data.z, reporterZ, _numberformat);	reporterX = _label + " = {" + reporterX + "," + reporterY + "," + reporterZ + "}";	DrawString(reporterX, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end // END "pt3dReporter.fxscript"point3d normColor;float rTGT, gTGT, bTGT;//define initial matrix values for straight pass-throughdesat = (colorize == 1) ? desat/100 : 1 - desat/100;	//makes the desaturate value a decimal value between 0 and 1if (colorFrom == 2)	hue = (hue + 360 )mod 360;	if (hue < 120);						//need a range of 0-120 on either side of zero		rTGT = (120 -  hue)/60;	else if (hue > 240);		rTGT = (120 - (abs(hue - 360)))/60;	else 		rTGT = 0;	end if		gTGT = (hue < 240) ? (120 - (abs(hue - 120)))/60 : 0;	bTGT = (hue > 120) ? (120 - (abs(hue - 240)))/60 : 0;	rTGT = (rTGT > 1) ? 1 : rTGT		//to prevent blowouts during colorization	gTGT = (gTGT > 1) ? 1 : gTGT	bTGT = (bTGT > 1) ? 1 : bTGT	if (colorize == 0 && (rTGT + gTGT + bTGT > 1))		//colorize values add up to more than 1		rTGT /= (rTGT + gTGT + bTGT); 		gTGT /= (rTGT + gTGT + bTGT); 		bTGT /= (rTGT + gTGT + bTGT); 	end if	targetColor = {255, rTGT, gTGT, bTGT};			// set targetColor to match the slider valuesend ifColorToVector(targetColor, normColor);SaturationAndColorizeToTarget(src1, dest, targetColor, desat);