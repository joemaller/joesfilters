filter "Joe's Saturation & Colorize";group "Joe's Filters [BETA]";input hue, "Hue Angle", Angle, 60, -360, 360 input desat, "Saturation", Slider, 100, 0, 1000 ramp 93 label "%" detent 100input colorize, "Colorize", checkbox, 1;input targetColor, "Target", Color, 255, 0, 0, 255;input colorFrom, "Color From", RadioGroup, 1, "Color", "Angle";input r1, "1: Red", slider, 0, 0, 10 	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input g1, "1: Green", slider, 0, 0, 10 	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input b1, "1: Blue", slider, 0, 0, 10 	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input r2, "2: Red", slider, 0, 0, 10 	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input g2, "2: Green", slider, 0, 0, 10	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input b2, "2: Blue", slider, 0, 0, 10	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input r3, "3: Red", slider, 0, 0, 10	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input g3, "3: Green", slider, 0, 0, 10	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input b3, "3: Blue", slider, 0, 0, 10	snap 0, 0.333, 0.5, 1, 2, 3, 4, 5;input title, "Joe's Filters", Label,"";input title1, "www.joesfilters.com", Label,"";InformationFlag("YUVaware");code// INCLUDE "basic_math.fxscript" r128on max(value _a, value _b); return (_a > _b) ? _a : _b; end on min(value _a, value _b); return (_a < _b) ? _a : _b; end on ceil(value _x); return(((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x)); end on floor(value _x); return(((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x)); end // END "basic_math.fxscript"on NormalizeColorVector(color _c, point3d _p)	if (_c.r + _c.g + _c.b == 0); _p *= 0; return; end if // do nothing for black input color	float _l;	_l = sqrt(power(_c.r,2) + power(_c.g,2) + power(_c.b,2));	_p = {_c.r, _c.g, _c.b};	_p /= _l;endon normalizeVector3d(point3d _V)	float _l;	_l = sqrt(power(_V.x,2) + power(_V.y,2) + power(_V.z,2));	_V /= _l // transforms _V into a normalized vector, length = 1;end // INCLUDE "NumReporter.fxscript" r124on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd, rzoom;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize * rzoom);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end// END "NumReporter.fxscript"// INCLUDE "pt3dReporter.fxscript" r124on Pt3dReporter(image _destIMG, point3d _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)		float rw, rh, ra, rd, rzoom;	string reporterX, reporterY, reporterZ;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,25,0,195};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(_justification);	setTextSize(_fontsize * rzoom);														NumToString(_data.x, reporterX, _numberformat);	NumToString(_data.y, reporterY, _numberformat);	NumToString(_data.z, reporterZ, _numberformat);	reporterX = _label + " = {" + reporterX + "," + reporterY + "," + reporterZ + "}";	DrawString(reporterX, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));end // END "pt3dReporter.fxscript"on VectorStretch(point3d _v)	_v /= max(_v.x, max(_v.y, _v.z));endon SaturationAndColorizeToTarget(image _src, image _dest, color _target, value _saturation, value _colorize)	// DEPENDENCIES:  NormalizeColorVector		//	_saturation is a floating point value between 0 and 10	//	_colorize is a boolean	//	_target is the color to target desaturation on.	float _w, _h;	DimensionsOf(dest, _w, _h);	image _img0[_w][_h];	point3d _normedColor;	NormalizeColorVector(_target, _normedColor);if ((_normedColor.x + _normedColor.y + _normedColor.z > 1));		//colorize values add up to more than 1	_normedColor /= (_normedColor.x + _normedColor.y + _normedColor.z); end if;	float _mat[3][3], _colorSpace;	float _rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb, _offset0[3];	_colorSpace = getPixelFormat(_src);	if (_colorSpace != kFormatRGB219)		ConvertImage(_src, _img0, kFormatRGB219);	else		_img0 = _src;	end if	if (getPixelFormat(_dest) != kFormatRGB219)		ConvertImage(_dest, _dest, kFormatRGB219);	end if//	if (_colorize != 1); _saturation = 1-_saturation; end if	//define initial matrix values for straight pass-through	_rr = 1; _rg = 0; _rb = 0;	_gr = 0; _gg = 1; _gb = 0;	_br = 0; _bg = 0; _bb = 1;	_rr -= (_rr - _normedColor.x) * _saturation;		_rg -= (_rg - _normedColor.x) * _saturation; 	_rb -= (_rb - _normedColor.x) * _saturation;	_gr -= (_gr - _normedColor.y) * _saturation;		_gg -= (_gg - _normedColor.y) * _saturation; 	_gb -= (_gb - _normedColor.y) * _saturation;	_br -= (_br - _normedColor.z) * _saturation;		_bg -= (_bg - _normedColor.z) * _saturation; 	_bb -= (_bb - _normedColor.z) * _saturation;	if (_colorize != 1)		_mat = {_rr, _rg, _rb, _gr, _gg, _gb, _br, _bg, _bb};	else		_mat = {_rr, _gg*_saturation/2, _bb*_saturation/2, _rr*_saturation/2, _gg, _bb*_saturation/2, _rr*_saturation/2, _gg*_saturation/2, _bb};		NormalizeColorVector(_target, _normedColor);	//_normedColor = {_target.r, _target.g, _target.b};//_normedColor /=255;/// WHY LIMIT THIS TO >1 INSTANCES?if (_normedColor.x + _normedColor.y + _normedColor.z > 1)	//_normedColor /= _normedColor.x + _normedColor.y + _normedColor.z;end if_normedColor -= 0.5;_normedColor *= _saturation ;_normedColor += 0.5;vectorStretch(_normedColor);if (_saturation > 1); _normedColor *= _saturation; end if		r1 = _normedColor.x                           		g2 = _normedColor.y                           		b3 = _normedColor.znormalizeVector3d(_normedColor);//	values need to go from 1 to the color value_mat = {r1, g1, b1, 	r2, g2, b2,		r3, g3, b3};	//	_mat = {r1, g2 * _saturation /3, b3* _saturation /3, 	r1* _saturation /3, g2, b3* _saturation /3,		r1* _saturation /3, g2* _saturation /3, b3};	end if		colorTransform(_img0, _dest, _mat, _offset0, _offset0);	if (getPixelFormat(_dest) != _colorSpace)	// return the same color space as we started with		ConvertImage(_dest, _dest, _colorSpace);	end if	_normedColor = {_mat[0][0], _mat[0][1], _mat[0][2]};	Pt3dReporter(_dest, _normedColor, "red", kfloat4, 0, 40, kcenterjustify);	_normedColor = {_mat[1][0], _mat[1][1], _mat[1][2]};	Pt3dReporter(_dest, _normedColor, "green", kfloat4, 40, 40, kcenterjustify);	_normedColor = {_mat[2][0], _mat[2][1], _mat[2][2]};	Pt3dReporter(_dest, _normedColor, "blue", kfloat4, 80, 40, kcenterjustify);		numReporter(_dest, _saturation, "_saturation", kfloat4, -50, 32, kcenterjustify);enddesat = (colorize == 1) ? desat/100 : 1 - desat/100;	//makes the desaturate value a decimal value between 0 and 1if (colorFrom == 2)	// convert angle to hue	float rTGT, gTGT, bTGT;	hue = (hue + 360 )mod 360;	if (hue < 120);						//need a range of 0-120 on either side of zero		rTGT = (120 -  hue)/60;	else if (hue > 240);		rTGT = (120 - (abs(hue - 360)))/60;	else 		rTGT = 0;	end if		gTGT = (hue < 240) ? (120 - (abs(hue - 120)))/60 : 0;	bTGT = (hue > 120) ? (120 - (abs(hue - 240)))/60 : 0;	rTGT = (rTGT > 1) ? 1 : rTGT		//to prevent blowouts during colorization	gTGT = (gTGT > 1) ? 1 : gTGT	bTGT = (bTGT > 1) ? 1 : bTGT	if (colorize == 0 && (rTGT + gTGT + bTGT > 1))		//colorize values add up to more than 1		rTGT /= (rTGT + gTGT + bTGT); 		gTGT /= (rTGT + gTGT + bTGT); 		bTGT /= (rTGT + gTGT + bTGT); 	end if	targetColor = {255, rTGT, gTGT, bTGT};			// set targetColor to match the slider valuesend ifSaturationAndColorizeToTarget(src1, dest, targetColor, desat, colorize);//ColorizeToTarget(src1, dest, targetColor, desat);//	//	point3d normColor;//	NormalizeColorVector(targetColor, normColor);//	Pt3dReporter(dest, normColor, "normcolor", kfloat4, 0, 32, kcenterjustify);//