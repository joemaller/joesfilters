Generator "Joe's Everything Converter"Group "BETA"//input th, "th",  slider, 5, 1,  255;//input spr, "spr",  slider, 8, 0,  254;//input blr, "blr",  slider, 5, 0,  100;//input precision, "precision",  slider, 0, 0,  10;input label0, "Source Clip", Label, "";input convertclip, "Clip", clip;input srcClip, "Source", popup, 3, "NTSC 720x480, 29.97fps", "PAL 720x576, 25fps", "24p NTSC Standard Pulldown", "24p NTSC Advanced Pulldown", "24p 640x480", "SONY MPEG 640x480, 25fps *fps skipframe fix", "Canon AVI 320x240, 15fps";input srcHasFields, "Field Dominance - Source Clip", popup, 1, "None (Progressive)", "Upper Field First (Interlaced)","Lower Field First (Interlaced)";input srcFAR, "Frame Aspect Ratio", popup, 2, "1:1", "1.33:1 (4:3)", "1.55:1 (14:9)","1.66:1 (5:3)", "1.77:1 (16:9)", "2:1", "2.35:1 (47:20)", "0.5625:1 (9:16)";input pulldown, "Pulldown Pattern", popup, 1, "None", " --- ", "Standard 3:2 SSwww (+4/5)", "Standard 3:2 wSSww (+0/5)", "Standard 3:2 wwSSw (+1/5)", "Standard 3:2 wwwSS (+2/5)", "Standard 3:2 SwwwS (+3/5)", " --- ", "Advanced 3:2 Swwww", "Advanced 3:2 wSwww", "Advanced 3:2 wwSww", "Advanced 3:2 wwwSw", "Advanced 3:2 wwwwS", " --- ", "Sony MPEG long-frame: aBB", "Sony MPEG FPS correction: BaB", "Sony MPEG FPS correction: BBa";input ffblend, "Spatial | Temporal Correction", slider, 100, 0, 100;input motionDiff, "motion differencing", checkbox, 1;input f3, "Highlight Motion", checkbox, 0;input pulldownoffset, "pulldownoffset", slider, 1, 0, 6 snap 0,1,2,3,4,5,6;input pulldownDuration, "pulldownDuration", slider, 5, 1, 6 snap 1,2,3,4,5,6;input PAL24fps, "PAL 24/25 FPS correction", checkbox, 0;input label1, "Output", Label, "";input rotater, "Rotate:", Popup, 1, "0¡ (No rotation)", "90¡ Clockwise", "90¡ Counter-Clockwise", "180¡", "Flip Horizontal", "Flip Vertical";input scaleOO, "Scale Original | Output", Slider, 0, -1, 1 detent -1, 0, 1;input fitWH, "Fit Width | Height", Slider, 0, -1, 1 detent -1, 0, 1;input hshift, "Pan (Horizontal Adjust)", slider, 0, -100,  100;input vshift, "Scan (Vertical Adjust)", slider, 0, -100,  100;input swapFields, "Reverse Fields - Output", checkbox, 0;input label2, "Debug stuff", Label, "";input showboxes, "Preview Frame Position", Checkbox, 1;input showvals, "Display Text", Checkbox, 0;input q, "text fader", Slider, 0.85, 0, 1;input fontsize, "Font Size", slider, 27, 6, 144; input tracking, "Tracking", slider, 5, -5, 10; InformationFlag("hasfields");RenderEachFrameWhenStillProducesAlphaAlphaType(kalpha);float RTfix;float natW,natH;codeif (natW == kundefined); getNativeSize(clip1, natW, natH); end if;float w,h,zoom;dimensionsOf(dest, w, h);zoom = w/natW;exposedbackground = 1;// numreporter function// Oct 12, 2003        On numReporter(value reporterData, string reporterstring, value subformat, value height)				//numReporter(number , "label", number format, vertical_position)                                string reporter;                color fontcolor;                float rw, rh, ra, rd, rzoom;                                DimensionsOf(dest, rw, rh);                rzoom = rw/720;                                fontcolor = {255,235,235,235};               fontcolor = {255,200,0,200};                if (frameFix % 2 == 0); fontcolor = {255,0, 255, 0}; else ; fontcolor = {255, 255, 0, 0}; end if;                settextfont("verdana");                setTextstyle(kbold);                setTextjustify(kcenterjustify);                setTextSize(fontsize * rzoom);                                                                                NumToString(reporterData, reporter, subformat); reporter = reporterstring + " = " + reporter                DrawString(reporter, 0, height, tracking,  dest, fontcolor , aspectof(dest))                End//end numreporter on ceil(value _x)	// simple function to round towards positive infinity	return( ((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x));endon floor(value _x)	// simple function to round towards negative infinity	return( ((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x));endon round(value _x, value _precision)	// rounding function with decimal precision		_x *= power(10, _precision)		if (_x > 0) 		_x = (_x - integer(_x)  >= 0.5) ? _x = ceil(_x) : floor(_x);	else		_x = (_x - integer(_x)  <= -0.5) ? _x = floor(_x) : ceil(_x);	end if	return _x/(power(10, _precision));end// Fix for RT Extreme and Generator half-frame data bugfloat durationFix, frameFix, fpsFix;	if (RTfix == kundefined)		if (frame - integer(frame) > 0) 			RTfix = true;		end if	end ifif (RTfix == true)		durationFix = duration * (fieldprocessing + 1);		frameFix = frame * (fieldprocessing + 1);	else		durationFix = duration;		frameFix = frame;end iffpsFix = fps;// field handling	// srcFieldDominance is a switch, 0 false, 1 true. 	// destField is either up (0) or down (1)	float srcFieldDominance, destField, convertH, convertW, srcFPS;destField = frame * 2 & 1; // outgoing field is first (0) or second (1)srcFieldDominance = (srcHasFields > 1) ? srcHasFields - 2 : 0; // Source uses - Upper Field First: 0; Lower Field First: 1;srcHasFields -= 1;	// sets this to true/falseswapFields ^= fieldprocessing; // bias towards lower-field first when we have fields//convert input values:	if (srcFAR == 1); srcFAR = 1/1; end if	if (srcFAR == 2); srcFAR = 4/3; end if	if (srcFAR == 3); srcFAR = 14/9; end if	if (srcFAR == 4); srcFAR = 5/3; end if	if (srcFAR == 5); srcFAR = 16/9; end if	if (srcFAR == 6); srcFAR = 2/1; end if	if (srcFAR == 7); srcFAR = 47/20; end if	if (srcFAR == 8); srcFAR = 9/16; end ifif (srcClip == 1) // NTSC	srcFPS = 30 * (1000/1001);	convertW = 720;	convertH = 480;else if (srcClip == 2) // PAL	srcFPS = 25;	convertW = 768;	convertH = 576;else if (srcClip == 3) 	srcFPS = 24 * (1000/1001);	convertW = 720;	convertH = 480;else if (srcClip == 4) 	srcFPS = 24 * (1000/1001);	convertW = 720;	convertH = 480;else if (srcClip == 5) 	srcFPS = 24;	convertW = 640;	convertH = 480;else if (srcClip == 6) // SONY MPEG	srcFPS = 25;	convertW = 640;	convertH = 480;else if (srcClip == 7) // Canon AVI	srcFPS = 15;	convertW = 320;	convertH = 240;end ifif (fps == 30 && srcFPS == 30 * (1000/1001))	fpsFix = srcFPS; 	// correct for the only occurance of 29.97 in FXScriptend if	srcFPS *= (srcHasFields + 1);	// frame rate correct for field based clips	fpsFix *= (srcHasFields + 1);	pulldown = pulldownoffset/pulldownDuration// float pulldownDuration, pulldownMethod;// // if (pulldown > 2 && pulldown < 8)// 	pulldown = (pulldown - 3 ) % 5 + 1;// 	pulldownDuration = 5;// 	pulldownMethod = 1 // Standard 3:2 pulldown// // else if (pulldown > 8 && pulldown < 14)// 	pulldown = (pulldown - 9 ) % 5 + 1;// 	pulldownDuration = 5;	// 	pulldownMethod = 2 // Advanced 3:2 pulldown// // // else if (pulldown > 14 && pulldown < 18)// 	pulldown = (pulldown - 15 ) % 3 + 1;// 	pulldownDuration = 3;// 	pulldownMethod = 2 // SONY MPEG 2/3 playback correction// // else// 	pulldownDuration = 1;// 	pulldownMethod = 0;// 	// end if// // // motion difference settingsfloat th, spr, blr;th = 5;spr = 8;blr = 5;//point xbox[4], ybox[4], srcbox[4];point ybox[4], srcbox[4], rotatetemp[4];float aspect, scaler, boxW, boxH, sourceDuration, sourceOffset, w, h, i, j, df;dimensionsOf(dest, w, h);aspect = aspectOf(dest);if ( rotater == 2 || rotater == 3)	srcFAR = 1/srcFAR;end if	fitWH += 1; fitWH /= 2; 	vshift /= 100; hshift /= 100;vshift = -vshift;if (srcFAR < (w/h)/aspect ) 	// fix for perceived directional adjustment of horiz. offset	hshift = -hshift;	vshift = -vshift;end ifscaler = ((srcFAR * aspect)/(w/h) - 1) * fitWH + 1;boxW = w * scaler;boxH = w / (srcFAR * aspect) * scaler;MakeRect(ybox, boxW/-2, boxH/-2, boxW, boxH)ybox *= boxW/convertW;for j = 0 to 3	ybox[j].x += ((boxW - w) * (hshift) * 0.5);	ybox[j].y += ((boxH - h) * (vshift) * 0.5) + destfield ^ swapFields;next;//									clipDuration = (sourceOffset + duration * (srcFPS/fpsFix)) - sourceOffset; //									clipRatio = getFrame/clipDuration;if ( rotater != 1)		rotatetemp = ybox;		if (rotater < 5)		rotater = (rotater < 4) ? (rotater * 2 - 5) * -1 : rotater/2;				for j = 0 to 3			ybox[j] = rotatetemp[(j + 4 + rotater) % 4];		next;			else if (rotater == 5) // do flip horizontal		for j = 0 to 3			ybox[j] = rotatetemp[j^1];		next;	else if (rotater == 6) // flip vertical				for j = 0 to 3			ybox[j] = rotatetemp[3-j];		next;		end if	end ifimage inbuf1[convertW][convertH];image inbuf2[convertW][convertH];image infield1[convertW][convertH/2];image infield2[convertW][convertH/2];image infield3[convertW][convertH/2];point frameBoxA[4], frameBoxB[4], halfBox[4], test[4];float clipDuration, clipRatio, getFrame, getFrame2, getField, nextClosest, s24p;float diffmap[256];getLimits(convertclip, sourceDuration, sourceOffset);if (sourceDuration > 0) // there is a clip to work with...	getFrame = frameFix/(fieldprocessing + 1) * (srcFPS/fpsFix)  + pulldown;	// selected frame of source clip			if srcClip == 3 // 24p standard pulldown				srcHasFields = false; // set to progressive for frame count but set field dominance for split-frame reconstruction		s24p = getFrame; 		// need to make sure 23.98 and 24p don't conflict...		// temp dubug for 24fps timelines:		//s24p = frameFix;				getFrame = (integer(s24p) * fpsFix/srcFPS); 		getFrame = (integer(s24p) * (1001/1000 * 30)/ (1001/1000 * 24)); 		getFrame -= integer((pulldownoffset  + 1 - s24p % 4)/4);		getFrame += 0.00005;	// ugh, I hate this...			if (integer(s24p) % 4 != (pulldownoffset + 1) % 4)			getFrame += integer((s24p % 4 + 2 - pulldownoffset) / 4 );			end if	end if		if srcClip == 4 // 24p advanced pulldown		srcHasFields = false; // set to progressive for frame count but set field dominance for split-frame reconstruction		getFrame += integer((getFrame - pulldownoffset)/(pulldownDuration-1)) + 1);	end if				getField = (getFrame - integer(getFrame) < 0.5) ? 0 : 1;		nextClosest = (getFrame*2/2 - integer(getFrame * 2)/2 < 0.25) ? -1 : 1; // indicates direction of next closest correct field	nextClosest = (getFrame + nextClosest < 0) ? 1 : nextClosest;	getFrame2 = getFrame + nextClosest/2;	GetVideo(convertclip, integer(getFrame) + sourceOffset, inbuf1);		boundsOf(inbuf1, frameBoxA);	boundsOf(infield1, halfbox);	frameBoxB = frameBoxA;	if (!srcHasFields)		// Progressive Source Clip && Progressive OR interlaced output						if (srcClip == 3 && (integer(s24p) % 4 == (pulldownoffset + 1) % 4)) // 24p standard pulldown split frame			getFrame += integer((s24p % 4 + 2 - pulldownoffset) / 4 );// existing frame already has correct second field, blit in correct first field from next frame			GetVideo(convertclip, integer(getFrame) + sourceOffset + 1, inbuf2);					for j = frameBoxA[0].y to frameBoxA[3].y step 2									frameBoxB[0].y = j + srcFieldDominance;				frameBoxB[1].y = j + srcFieldDominance;				frameBoxB[2].y = j + 1 + srcFieldDominance;				frameBoxB[3].y = j + 1 + srcFieldDominance;								//fillPoly(frameBoxB, inbuf1, kwhite);						BlitRect(inbuf2, frameBoxB, inbuf1, frameBoxB);							next;		end if								BlitRect(inbuf1, frameBoxA, dest, ybox);					else // Interlaced source		if (fieldprocessing)	// Interlaced Sequence (Interlaced Source Clip)			if (destField == getField)	// fields match send selected field 												for j = 0 to 3					frameBoxA[j].y  += getField ^ srcFieldDominance; // adjust field-smash source by which field is selected and field dominance				next;					BlitRect(inbuf1, frameBoxA, infield1, halfBox); 				BlitRect(infield1, halfBox, dest, ybox); 									// debug block:				makeRect(test, 200, 200, 5, 5); fillPoly(test, dest, kyellow);				else	// field mismatch												for j = 0 to 3					frameBoxA[j].y  += getField ^ srcFieldDominance; 	// A is getField					frameBoxB[j].y  += destField ^ srcFieldDominance; 	// B is opposite of getField -- always equal destField since this can't happen unless getField != destField				next;									if (((ffblend < 100) && (integer(getFrame) != integer(getFrame2))) || motionDiff)					GetVideo(convertclip, integer(getFrame + nextClosest) + sourceOffset, inbuf2);	 // get next closest frame				end if					if (integer(getFrame) != integer(getFrame2))		// getFrame2 is another frame					BlitRect(inbuf1, frameBoxB, infield3, halfBox); // send spatially correct field of inbuf1 to field 3 (used for masking)					BlitRect(inbuf2, frameBoxB, infield2, halfBox); // send spatially correct field of inbuf2 to field 2 (spatially correct frame)				else					BlitRect(inbuf1, frameBoxB, infield2, halfBox); 					BlitRect(inbuf2, frameBoxB, infield3, halfBox); 				end if																																if (motionDiff)						diffmap *=0;										spr = (spr/2 > th ) ?  th*2 : spr;										for j = 0 to th; diffmap[j] = 1; next;					for j = (th - spr/2) to (th + spr/2); diffmap[j] = 1- power((th - spr/2 - j)/ spr, 2); next; 										Difference(infield2, infield3, infield3, kalpha);					Desaturate(infield3, infield3);					BlurChannel(infield3, infield1, blr, 0, 0, 1, 0, (convertW/convertH)/srcFAR);					LevelMap(infield1, infield1, linearramp, diffmap, diffmap, diffmap);					ChannelCopy(infield1, infield2, kgreen, knone, knone, knone);										if f3; ChannelFill(infield2, -1, 0, 255, 0); end if // fill against motion									end if					BlitRect(inbuf1, frameBoxA, infield1, halfBox);				matte(infield2, infield1, infield1, ffblend/100, kalpha);				BlitRect(infield1, halfBox, dest, ybox); 										makeRect(test, 200, 200, 5, 5); fillPoly(test, dest, kmagenta);		// debug block			end if		else 	// Progressive Sequence (Interlaced Source Clip)								for j = 0 to 3				frameBoxA[j].y  += getField ^ srcFieldDominance; 	// A is getField				frameBoxB[j].y  += destField ^ srcFieldDominance; 	// B is opposite of getField -- always equal destField since this can't happen unless getField != destField			next;			if (motionDiff)									// motion difference fields surrounding selected fields								GetVideo(convertclip, integer(getFrame + nextClosest) + sourceOffset, inbuf2);	 // get next frame							if (integer(getFrame) != integer(getFrame2))		// getFrame2 is another frame					BlitRect(inbuf1, frameBoxB, infield3, halfBox); // send spatially correct field of inbuf1 to field 3 (used for masking)					BlitRect(inbuf2, frameBoxB, infield2, halfBox); // send spatially correct field of inbuf2 to field 2 (spatially correct frame)				else					BlitRect(inbuf1, frameBoxB, infield2, halfBox); 					BlitRect(inbuf2, frameBoxB, infield3, halfBox); 				end if				diffmap *=0;								spr = (spr/2 > th ) ?  th*2 : spr;								for j = 0 to th; diffmap[j] = 1; next;				for j = (th - spr/2) to (th + spr/2); diffmap[j] = 1- power((th - spr/2 - j)/ spr, 2); next; 								Difference(infield2, infield3, infield3, kalpha);				Desaturate(infield3, infield3);				BlurChannel(infield3, infield1, blr, 0, 0, 1, 0, (convertW/convertH)/srcFAR);				LevelMap(infield1, infield1, linearramp, diffmap, diffmap, diffmap);				ChannelCopy(infield1, infield2, kgreen, knone, knone, knone);											boundsOf(inbuf1, test);				BlitRect(infield2, halfBox, inbuf2, test); 		// this is a bummer, should be the next-closest spatial frame				ChannelCopy(inbuf1, inbuf2, knone, kred, kgreen, kblue);				if f3; ChannelFill(inbuf2, -1, 0, 255, 0); end if // fill against motion							end if			BlitRect(inbuf1, frameBoxA, infield1, halfBox); 						boundsOf(inbuf1, frameBoxA);			BlitRect(infield1, halfBox, inbuf1, frameBoxA); 			matte(inbuf2, inbuf1, inbuf1, ffblend/100, kalpha);			BlitRect(inbuf1, frameBoxA, dest, ybox); 							makeRect(test, 200, 200, 5, 5); fillPoly(test, dest, kblue + getField);		// debug block:				end if	end ifend if	if srcClip == 3 // 24p standard pulldown		if (floor(s24p) % 4 == (pulldownoffset + 1) % 4)		//	channelmultiply(dest, dest,  1, q, 0, q);				end if//		getFrame *= fpsFix/srcFPS; 	end ifif (showboxes)	//Line(srcbox[0], srcbox[2], dest, kgray, 1)	///Line(srcbox[1], srcbox[3], dest, kgray, 1)	//	Line(halfBox[0], halfBox[1], dest, kgray, 1)//	Line(halfBox[3], halfBox[2], dest, kgray, 1)	boundsOf(dest, test);									ybox *= 0.5;	test *= 0.5;	FramePoly(test, dest, kblack, 3);	FramePoly(ybox, dest, kblack, 3);	FramePoly(test, dest, kgray, 2);	FramePoly(ybox, dest, kwhite, 2);end ifif (showvals)	float aaa;		aaa = 0;	if ((frame * 2) & 1) == 1		aaa = 0	else		aaa = -h/2;	end if									channelMultiply(dest, dest, 1, q, q, q);		numReporter(frame, "frame", kfloat2, h/2*0.1 + aaa)	numReporter(s24p, "s24p", kfloat4, h/2*0.2 + aaa)	numReporter(getFrame, "getFrame", kfloat2, h/2*0.3 + aaa)//	numReporter(getFrame2, "getFrame2", kfloat2, h/2*0.3 + aaa)//	numReporter(getFrame + pulldownoffset/pulldownDuration, "getFrame+ pulldownoffset/pulldownDuration", kfloat2, h/2*0.3 + aaa)//	numReporter(getFrame*2/2 - integer(getFrame * 2)/2, "(getFrame*2/2 - integer(getFrame * 2)/2", kfloat2, h/2*0.4 + aaa)	numReporter(integer((pulldownoffset  + 1 - s24p % 4)/4), "int((pulldownoffset+1-s24p%4)/4)", kfloat2, h/2*0.4 + aaa)//	numReporter(frameFix, "frameFix", kfloat2, h/2*0.5 + aaa)//	numReporter(destField, "destField", kfloat2, h/2*0.4 + aaa)//	numReporter(getField, "getField", kfloat2, h/2*0.5 + aaa)//	numReporter(nextClosest, "nextClosest", kfloat2, h/2*0.6 + aaa)			//boundsOf(infield1, ybox);	//numReporter(halfBox[2].y, "halfBox[2].y", kfloat6, h/2*0.8 + aaa)//	numReporter(fieldprocessing, "fieldprocessing", kfloat2, h/2*0.8)		numReporter(fps, "fps", kfloat6, h/2*0.5 + aaa)	numReporter(srcFPS, "srcFPS", kfloat6, h/2*0.6 + aaa)	numReporter(fpsFix, "fpsFix", kfloat6, h/2*0.7 + aaa)//	numReporter(pulldown, "pulldown", kfloat2, h/2*0.7 + aaa)	numReporter(pulldownoffset, "pulldownoffset", kfloat2, h/2*0.8 + aaa)	numReporter(pulldownDuration, "pulldownDuration", kfloat4, h/2*0.9 + aaa)//	numReporter(fieldprocessing, "fieldprocessing", kfloat2, h/2 + aaa)//	numReporter(ybox[1].y, "ybox[1].y", kfloat6, h/2*0.7 + aaa)//	numReporter(ybox[2].y, "ybox[2].y", kfloat6, h/2*0.8 + aaa)	//numReporter(frameBoxB[2].y, "frameBoxB[2].y", kfloat6, h/2*0.8 + aaa)	if (getField != destField)		if (integer(getFrame) != integer(getFrame2))			if (getFrame*2/2 - integer(getFrame * 2)/2) < 0.25//				numReporter(-1, "BEFORE", kfloat2, h/2*0.9 + aaa);			else//				numReporter(1, "AFTER", kfloat2, h/2*0.9 + aaa)			end if		end if	end ifend if	numReporter(ceil(0.25, precision), 	"ceil(0.25, precision)", kfloat6, h/2*0)	numReporter(ceil(1.5, precision), 	"ceil(1.5, precision)", kfloat6, h/2*0.1)	numReporter(ceil(2.5, precision), 	"ceil(2.5, precision)", kfloat6, h/2*0.2)	numReporter(ceil(3.5,precision), 		"ceil(3.5, precision)", kfloat6, h/2*0.3)	numReporter(ceil(-3.5, precision), 	"ceil(-3.5, precision)", kfloat6, h/2*0.4)	numReporter(ceil(-2.5, precision), 	"ceil(-2.5, precision)", kfloat6, h/2*0.5)	numReporter(ceil(-1.5, precision), 	"ceil(-1.5, precision)", kfloat6, h/2*0.6)	numReporter(ceil(-0.25, precision), 	"ceil(-0.25, precision)", kfloat2, h/2*0.7)	numReporter(ceil(-12.15235678, precision), 	"ceil(-12.15235678, precision)", kfloat6, h/2*0.8)	numReporter(ceil(0, precision), 		"ceil(0, precision)", kfloat6, h/2*0.9)