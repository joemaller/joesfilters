Generator "Joe's Everything Converter"Group "BETA"input labelsource, "Source Clip", Label, "";input convertclip, "Clip", clip;input srcClip, "Type", popup, 3, "NTSC 720x480 (DV), 29.97fps", "NTSC 720x486 (D1), 29.97fps", "PAL 720x576, 25fps", "24p NTSC Standard Pulldown", "24p NTSC Advanced Pulldown", "24p 640x480", "SONY MPEG 640x480, 25fps *fps skipframe fix", "Canon AVI 320x240, 15fps", "HD 1080i50 1920x1080, 25fps", "HD 1080i60 1920x1080, 29.97fps", "HD 720p24 1280x720, 23.98fps", "HD 720p24 1280x720, 24fps";//input srcHasFields, "Field Dominance", popup, 3, "None (Progressive)", "Upper Field First (Interlaced)","Lower Field First (Interlaced)";input srcFAR, "Frame Aspect Ratio", popup, 2, "1:1", "1.33:1 (4:3)", "1.55:1 (14:9)", "1.66:1 (5:3)", "1.78:1 (16:9)", "1.85:1 (37:20)", "2:1", "2.20:1 (11:5)", "2.35:1 (47:20)", "2.40:1 (12:5)", "2.55:1 (51:20)", "0.5625:1 (9:16)";input pulldown, "Pulldown Pattern", popup, 1, "Not working yet", " --- ", "Standard 3:2 SSwww (+4/5)", "Standard 3:2 wSSww (+0/5)", "Standard 3:2 wwSSw (+1/5)", "Standard 3:2 wwwSS (+2/5)", "Standard 3:2 SwwwS (+3/5)", " --- ", "Advanced 3:2 Swwww", "Advanced 3:2 wSwww", "Advanced 3:2 wwSww", "Advanced 3:2 wwwSw", "Advanced 3:2 wwwwS", " --- ", "Sony MPEG long-frame: aBB", "Sony MPEG FPS correction: BaB", "Sony MPEG FPS correction: BBa";//input PAL24fps, "PAL 24/25 FPS correction", checkbox, 0;//input reverseSRCfields, "Reverse Fields", checkbox, 0;//input tempBlend, "Temporal Blending", checkbox, 0;input labelfitting, "Fitting", label, "";input fitMethod, "Fit Between", Popup, 1, "Width  <-> Height", "Width  <-> Original", "Height <-> Original";input fitWH, "Fitting", Slider, 0, -1, 1 detent -1, 0, 1;input xshift, "Pan (Horz Adj)", slider, 0, -100,  100 label "%";input yshift, "Scan (Vert Adj)", slider, 0, -100,  100 label "%";//input labelpulldown, "Pulldown", label, "";//input pulldownOffset, "pulldownoffset", slider, 1, 0, 6 snap 0,1,2,3,4,5,6;//input pulldownDuration, "pulldownDuration", slider, 5, 1, 6 snap 1,2,3,4,5,6;input label1, "Output", Label, "";input rotation, "Rotate:", angle, 0, -360, 360 detent -360, -270, -180, -90, 0, 90, 180, 270, 360;input mirror, "Mirror:", popup, 1, "none", "Mirror Horizontal", "Mirror Veritcal", "Mirror Both"; //input swapFields, "Reverse Fields - Output", checkbox, 0;input labelMD, "Motion Differencing", label, "";input ffblend, "Spatial | Temporal Correction", slider, 100, 0, 100;input motionDiff, "motion differencing", checkbox, 1;input showmask, "Show Mask", checkbox, 0;input maskDetail, "Mask Detail", slider, 0, -10, 10;input label2, "Debug stuff", Label, "";input showboxes, "Preview Frame Position", Checkbox, 0;input showvals, "Display Text", Checkbox, 0;input showspot, "debug block", Checkbox, 1;input pulldowncheck, "pulldowncheck", Checkbox, 1;input q, "text fader", Slider, 0.75, 0, 1;input fontsize, "Font Size", slider, 27, 6, 144; input tracking, "Tracking", slider, 5, -5, 10; InformationFlag("hasfields");InformationFlag("YUVaware");RenderEachFrameWhenStillProducesAlphaAlphaType(kalpha);//float lastFrame,thisFrame;//float CLIPDUR, CLIPOFFSET;float RTfix;codeexposedbackground = 1;// create RTcorrect values for frame and ratio://if (lastFrame == kundefined); lastFrame = 0; thisFrame = 0; end if//lastFrame = thisFrame; thisFrame = frame - integer(frame);//	float RTFrame, RTRatio;//	RTFrame = (thisFrame != 0 || lastFrame != 0) ? frame * (fieldprocessing + 1) : frame;//	RTRatio = RTFrame/duration;	// identical to ratio, only changes is RTFrame is different//	RTFrame = ratio * duration;//	RTRatio = ratio;// Fix for RT Extreme and Generator half-frame data bugfloat durationFix, frameFix, destFPS;	if (RTfix == kundefined)		if (frame - integer(frame) > 0) 			RTfix = true;		end if	end ifif (RTfix == true)		durationFix = duration * (fieldprocessing + 1);		frameFix = frame * (fieldprocessing + 1);	else		durationFix = duration;		frameFix = frame;end ifdestFPS = fps;// INCLUDE "DeInterlaceFast.fxscript"  v1.5on DeInterlaceFast(image _srcIMG, image _destIMG, value _field)		// _srcIMG : source image	// _destIMG : destination image	// _field : 0 = top field, 1 = bottom field	// this might fail at some future time if the scaling method in FCP changes	if (_field != 0 && _field != 1)		ErrorReporter(dest, "_field must be a boolean");		return;	end if				float _j;	point _r1[4], _r2[4];	BoundsOf(_srcIMG, _r1);		if (_field) // second field, shift box down		_r1[0].y += 1;	// shift top row down		_r1[1].y += 1;		if ((_r1[3].y - _r1[0].y) & 1) 	// frame height needs to be even			_r1[2].y += 1;			// shift bottom down one row			_r1[3].y += 1;		end if	else // first field		if ((_r1[3].y - _r1[0].y) & 1) // odd frame height			_r1[2].y -= 1; // odd frame height, trim one row off of bottom			_r1[3].y -= 1;		end if	end if	image _halfIMG[_r1[1].x - _r1[0].x][(_r1[3].y - _r1[0].y) /2];	BoundsOf(_halfIMG, _r2);	BlitRect(_srcIMG, _r1, _halfIMG, _r2); // smash blit (isolates fields)		makeRect(_r2, _r2[0].x, _r2[0].y - _field/2, _r2[1].x - _r2[0].x, _r2[3].y - _r2[0].y)	// corrects for  field bouncing	BoundsOf(_destIMG, _r1);	BlitRect(_halfIMG, _r2, _destIMG, _r1);end// END "DeInterlaceFast.fxscript" // INCLUDE "FastRotate.fxscript"  v1.2on FastRotate(point _srcPoly, value _rotation, value _aspect)	// a quick tool for rotating a polygon around a centerpoint.	// saves the step of having to define an extra point variable and call the centerOf function first	point _centerPt;	centerOfPoly(_srcPoly, _centerPt);	Rotate(_srcPoly, _centerPt, _rotation, _aspect)end// END "FastRotate.fxscript" // INCLUDE "mirrorRect.fxscript"  v1.2on mirrorRect(point _srcRect, value _flipX, value _flipY)	// mirror a rectangular area	// _flipX and _flipY are booleans		float _j;	point _rotatetemp[4];		_rotatetemp = _srcRect;		if (_flipX && !_flipY) // flipX		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[_j^1];		next;	else if (_flipY && !_flipX) // flip vertical		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[3-_j];		next;	else if (_flipX && _flipY) // flip both		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[(_j + 2) % 4];		next;	end ifend// END "mirrorRect.fxscript" // INCLUDE "fitPoly.fxscript"  v1.1on fitPoly(point _srcPoly, value _srcPolyPts, point _frameRect, point _destRect, value _hshift, value _vshift)	// a pan/scan tool used to place a multi-sided poly inside frame rectangle with offset	// fitting values are -100 - 100 percentage values used to place _srcRect when sizes differ	// the new rectangle is placed in _destRect	// source rectangles are moved around until they align with the dest frame's edges 			point _box, _frame;	float _j;	DimensionsOfPoly(_srcPoly, _srcPolyPts, _box);	DimensionsOfPoly(_frameRect, 4, _frame);	_hshift /= (_box.x > _frame.x) ? 100 : -100;		//adjust perceived direction shifts	_vshift /= (_box.y > _frame.y) ? 100 : -100;	_hshift = ((_box.x - _frame.x) * _hshift)/2;	_vshift = ((_box.y - _frame.y) * _vshift)/2;	///MakeRect(_destRect, _box.h/-2 + _hshift, _box.v/-2 + _vshift, _box.h, _box.v)		_destRect = _srcPoly;	for _j = 0 to 3		_destRect[_j].x += _hshift;		_destRect[_j].y += _vshift;	next;	end// END "fitPoly.fxscript" on scaleToFit(point _srcRect, point _frameRect, point _destRect, value _scaler, value _fitMethod)	// scales the original frame by 1 of 3 scaling ranges	// _srcRect		: 	Original Frame Box	// _frameRect	:	destination frame box	// _destRect	: 	destination for scaled box results		// 1 = Fit width <-> height	// 2 = Fit width <-> original	// 3 = Fit height <-> original		point _fit	DimensionsOfPoly(_srcRect,  4,  _fit)				_fit.x = (_frameRect[1].x - _frameRect[0].x)/_fit.x;	_fit.y = (_frameRect[3].y - _frameRect[0].y)/_fit.y;				if 		(_fitMethod == 1); 	_scaler = _scaler * (_fit.y - _fit.x) + _fit.x;		// W H	else if 	(_fitMethod == 2);	_scaler = _scaler * (1 - _fit.x) + _fit.x;		// W O	else if 	(_fitMethod == 3);	_scaler = _scaler * (1 - _fit.y) + _fit.y;		// H O	end if	_destRect = _srcRect;	_destRect *= _scaler;		end// INCLUDE "NumReporter.fxscript"  v1.1on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)		float rw, rh, ra, rd, rzoom;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(kcenterjustify);	setTextSize(_fontsize * rzoom);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));end// END "NumReporter.fxscript" // INCLUDE "basic math.fxscript"  v1.1on max(value _a, value _b); return (_a > _b) ? _a : _b; end on min(value _a, value _b); return (_a < _b) ? _a : _b; end on ceil(value _x); return(((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x)); end on floor(value _x); return(((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x)); end // END "basic math.fxscript" // INCLUDE "round.fxscript"  v1.2on round(value _x, value _precision)	// rounding function with decimal precision		_x *= power(10, _precision)		if (_x > 0) 		_x = (_x - integer(_x)  >= 0.5) ? ceil(_x) : floor(_x);	else		_x = (_x - integer(_x)  <= -0.5) ? floor(_x) : ceil(_x);	end if	return _x/(power(10, _precision));end // END "round.fxscript"  // INCLUDE "DifferenceMask.fxscript"  v1.2on DifferenceMask(image _src1, image _src2, image _dest, value _threshold, value _steps, value _softness)		// dependencies:	//			makeThresholdMapBez	//			channelcopyfit	// _src1, src2 : images to compare	// _dest : destination image buffer, results will replace this image's alpha channel	// _threshold : Threshold break for difference mask	// _steps : number of steps around threshold point	// _softness : spread of the difference mask before thresholding.		// compares two images and generates a mask based on differences between the two	// the resulting mask will replace whatever alpha channel is in _dest			float _diffmap[256];	makeThresholdMapBez(_diffmap, _threshold, _steps, 255)		point _src1Box[4], _src2Box[4];	boundsOf(_src1, _src1Box);	boundsOf(_src2, _src2Box);		if (_src1Box[2].x * _src1Box[2].y == _src2Box[2].x * _src2Box[2].y)	// _src1 and _src2 should be the same size, should be most common		image _temp1[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y],  _temp2[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y];				_temp1 = _src1;		_temp2 = _src2;			else if (_src1Box[2].x * _src1Box[2].y > _src2Box[2].x * _src2Box[2].y)	// _src1 has more pixels, scale _src1 down to match _src2 (bias for speed)		image _temp1[_src2Box[1].x - _src2Box[0].x][_src2Box[3].y - _src2Box[0].y],  _temp2[_src2Box[1].x - _src2Box[0].x][_src2Box[3].y - _src2Box[0].y];		_temp2 = _src2;		blitRect(_src1, _src1Box, _temp1, _src2Box);	else	// _src1 has fewer pixels than _src2, scale _src2 down to match		image _temp1[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y],  _temp2[_src1Box[1].x - _src1Box[0].x][_src1Box[3].y - _src1Box[0].y];			_temp1 = _src1;		blitRect(_src2, _src2Box, _temp2, _src1Box);	end if		Difference(_temp1, _temp2, _temp1, kalpha);	// setting targets up beforehand is faster	BlurChannel(_temp1, _temp2, _softness, 1,1,1,1, aspectOf(_dest));		if (GetPixelFormat(dest) == kFormatYUV219)		LevelMap(_temp2, _temp2, linearRamp, _diffmap, linearRamp, linearRamp);		channelcopyfit(_temp2, _dest, kred, knone, knone, knone);	else		LevelMap(_temp2, _temp2, linearRamp, linearRamp, _diffmap, linearRamp);		channelcopyfit(_temp2, _dest, kgreen, knone, knone, knone);	end ifend// END "DifferenceMask.fxscript" // INCLUDE "makeThresholdMapBez.fxscript"  v1.1on makeThresholdMapBez(float _lmap, value _th, value _steps, value _mapLength)		// a fast thresholding function using BezToLevelMap instead of for:next loops		// _th is the point to thrreshold around, _steps are the number of grays around _th		// mapLength is 255 for 8-bit maps			point _p1, _p2;		float _top, _bottom;		if (_th - _steps/2 < 0)		_steps = _th * 2;	else if (_th + _steps/2 > _mapLength)		_steps = (_mapLength - _th) * 2;	end if		if (_th & 1 == 0)	// even		_p1 = {floor(_th - _steps/2)/_mapLength, 0};				_p2 = {floor(_th + _steps/2)/_mapLength, 1};			else // _th is odd		_p1 = {ceil(_th - _steps/2)/_mapLength, 0};				_p2 = {ceil(_th + _steps/2)/_mapLength, 1};			end if	BezToLevelMap(_lmap, _p1, _p1, _p2, _p2, 0, _mapLength, TRUE);end// END "makeThresholdMapBez.fxscript" // INCLUDE "getField.fxscript"  v1.4on getField(clip _clip1, value _offset, image _dest, value _nativeW, value _nativeH, value _field);	//REQUIRES: 	DeInterlaceFast.fxscript	//				ErrorReporter.fxscript	// getField(clip, frame, dest, 720, 480, 1);	// replacement for GetVideo which returns a single field of interlaced video	// basic getVideo call plus dinmensions and field selection	// field is 0 or 1 to match deinterlace functions		// getvideo into half-height buffers appears to return only the upper field (line 0)	// that means de-intelacing can be skipped for matching fields to save processing		if (_field < 0 || _field > 1)		ErrorReporter(dest, "_field value out of range");		return;	end if			if (_field) //(_field == 0)		image _half[_nativeW][_nativeH/2];		point _halfBox[4], _destBox[4];		boundsOf(_half, _halfBox);		boundsOf(_dest, _destBox);				if (_halfBox[0] == _destBox[0] && _halfBox[2] == _destBox[2])	// _half is the same size as _dest, skip a blit					getVideo(_clip1, _offset, _dest);		else		// _half and _dest are different sizes, use blitRect							getVideo(_clip1, _offset, _half);			blitRect(_half, _halfBox, _dest, _destBox);				end if						else // _field == 1		image _full[_nativeW][_nativeH];		getVideo(_clip1, _offset, _full);		DeInterlaceFast(_full, _dest, _field);	end if	end	// end getField// END "getField.fxscript" // INCLUDE "ChannelCopyFit.fxscript"  v1.5on ChannelCopyFit(image _src, image _dest, value _A, value _R, value _G, value _B)	// a combination of channelcopy and blitrect, scales any specified channel to fit the target	// specifically for cases where a channel source is not the same size as the channel destination	// _A, _R, _G & _B work just like Channelcopy and are of the set {kalpha, kred, kgreen, kblue}	// This is meant to be a more versatile drop-in replacement for ChannelCopy		point _srcBox[4], _destBox[4];	boundsOf(_src, _srcBox);	boundsOf(_dest, _destBox);	if (_srcBox[2] == _destBox[2])		// sizes are equal, normal channelcopy...		channelCopy(_src, _dest, _A, _R, _G, _B);	else	// sizes are unequal, do blit then channel						//		check for size differences		// 		do channelcopy on larger image to preserve resolution 						if (_srcBox[2].x * _srcBox[2].y < _destBox[2].x * _destBox[2].y)	// _src is smaller than _dest			image _temp[_destBox[1].x - _destBox[0].x][_destBox[3].y - _destBox[0].y]; // create second dest-sized image buffer			blitRect(_src, _srcBox, _temp, _destBox);			channelCopy(_temp, _dest, _A, _R, _G, _B);				else // _src is larger than _dest			image _temp[_srcBox[1].x - _srcBox[0].x][_srcBox[3].y - _srcBox[0].y]; // create second src-sized image buffer			blitRect(_dest, _destBox, _temp, _srcBox);			channelCopy(_src, _temp, _A, _R, _G, _B);			blitRect(_temp, _srcBox, _dest, _destBox);				end if	end ifend// END "ChannelCopyFit.fxscript" // INCLUDE "ArrayPointCount.fxscript"  v1.2on indexExistsPt(value _i, point _ar);return(_ar[_i] == true); endon ArrayPointCount(point _ar)	float _l, _r, _seed, _step, _counter;	_seed = 7; // somewhat arbitrary, chosen after lots of performance testing	_step = _seed;	// store seed for later	 	_l = 1 // set this to save a loop checking the zeroth index	_r = _l + _seed;	repeat while true		_counter++;		if (indexExistsPt(_l, _ar) && indexExistsPt(_r, _ar))	// both values in array			_l = _r+1;	// start at _r+1 to prevent double-checking values			_r = _l + _step;			_step += _seed * _counter;		else if (!indexExistsPt(_l, _ar) && !indexExistsPt(_r, _ar))	// no values in array			return _l;	// stepped one over _r previously, last index must be _l-1, return _l to compenstate for count vs. index off-by-one		else 	// bottom value in array, top not. Half top and step bottom			_step = _r; // temporary storage of the _r variable			_l = _l+1; // increment _l to prevent double-checking values			_r = _l + integer((_r - _l)/2);	// half the distance between _l and _r			_step -= _r; // difference between old _r and new _r		end if	end repeat;end// END "ArrayPointCount.fxscript" // INCLUDE "CenterOfPoly.fxscript"  v1.1on CenterOfPoly(point _poly, point _center)	float _x, _arLength;	_arLength = arrayPointCount(_poly);	_center = _poly[0];	for _x = 1 to _arLength - 1		_center += _poly[_x]	next;	_center /= _arLengthend// END "CenterOfPoly.fxscript" // INCLUDE "DimensionsOfPoly.fxscript"  v1.1on DimensionsOfPoly(point _srcPoly, value _srcPolyPts, point _WH)		// returns the maximum  Width/Height of n-sided polys 			// _srcPoly 		: 		polygon to fit inside _destRect	// _srcPolyPts 		: 		number of points in _srcPoly, because it can't be programatically determined	// _WH			:		a single point used to return two float values, x = Width, y = Height	float _j;	point _topLeft, _bottomRight;		_topLeft = _srcPoly[0];	_bottomRight = _srcPoly[2];		repeat with _j = 0 to ( _srcPolyPts -1)			if (_srcPoly[_j].x < _topLeft.x)			_topLeft.x = _srcPoly[_j].x;		else if (_srcPoly[_j].x > _bottomRight.x)			_bottomRight.x = _srcPoly[_j].x;		end if		if (_srcPoly[_j].y < _topLeft.y)							_topLeft.y = _srcPoly[_j].y;		else if (_srcPoly[_j].y > _bottomRight.y)			_bottomRight.y = _srcPoly[_j].y;		end if	end repeat	_WH.x = abs(_topLeft.x) + abs(_bottomRight.x);	_WH.x = _bottomRight.x - _topleft.x;	_WH.y = _bottomRight.y - _topleft.y;//	NumReporter(dest, _WH.x, "_polyW", kfloat2, destH/2 * -0.2, 32, 1);//	NumReporter(dest, _WH.y, "_polyH", kfloat2, destH/2 * -0.3, 32, 1);	end	// END "DimensionsOfPoly.fxscript" on gcd(value _m, value _n)	// calculate the greatest common divisor for two numbers	// based on various implementations of Euclid's algorithm	if (_m != 0 && _n != 0)		float _r;		repeat while true			_r = _m % _n;	          	_m = _n;            	_n = _r;            	if (_r == 0)            		exit repeat            	end if		end repeat	else		_m = 0;	end if	return _m;	// gcd of input numbersend // following is JavaScript, translate to FXScript//	//	function djGCD2(_m, _n) {//			// my own non-recursive implementation of Dijkstra's algorithm//		while (_m != _n) {//			if (_m*1 > _n*1) {	// need to use multiply by 1 to force-cast the variables to numbers or the logic fails, ugh...//				_m -= _n;//			} else {//				_n -= _m;//			}//		}//		return _m;//	}//// END FUNCTIONSfloat pulldownDuration, pulldownOffset;float pulldownADV, pulldownSTD, srcHasFields;float srcFieldDominance, destField, convertH, convertW, srcFPS;float scaler, boxW, boxH, sourceDuration, sourceOffset, i, j, df;float clipDuration, clipRatio, getFrame, getFrame2, theField, nextClosest, s24p, diffmap[256];float blendOpacityfloat w,h,zoom;	destFPS = fps;destField = frame * 2 & 1; // outgoing field is temporally first (0) or second (1)//srcFieldDominance = (srcHasFields > 1) ? srcHasFields - 2 : 0; // srcFieldDominance: 0= Upper Field First, 1= Lower Field First//convert input values:	// leave off srcFAR == 1 since that would equal 1;	if (srcFAR == 2); srcFAR = 4/3;	else if (srcFAR == 3); srcFAR = 14/9;	else if (srcFAR == 4); srcFAR = 5/3;	else if (srcFAR == 5); srcFAR = 16/9;	else if (srcFAR == 6); srcFAR = 37/20;	else if (srcFAR == 7); srcFAR = 2;	else if (srcFAR == 8); srcFAR = 11/5;	else if (srcFAR == 9); srcFAR = 47/20;	else if (srcFAR == 10); srcFAR = 12/5;	else if (srcFAR == 11); srcFAR = 51/20;	else if (srcFAR == 12); srcFAR = 9/16;	end ifpulldownSTD = false;pulldownADV = false;if (srcClip == 1) // NTSC DV	srcFPS = 30 * (1000/1001);	convertW = 720;	convertH = 480;	srcHasFields = true;	srcFieldDominance = 1;else if (srcClip == 2) // NTSC D1	srcFPS = 30 * (1000/1001);	convertW = 720;	convertH = 486;	srcHasFields = true;	srcFieldDominance = 0;else if (srcClip == 3) // PAL	srcFPS = 25;	convertW = 768;	convertH = 576;	srcHasFields = true;	srcFieldDominance = 1;else if (srcClip == 4) 	// 24p NTSC Standard Pulldown	srcFPS = 24 * (1000/1001);	convertW = 720;	convertH = 480;	pulldownSTD = true;	srcHasFields = false;	srcFieldDominance = 1;else if (srcClip == 5)	// 24p NTSC Advanced Pulldown	srcFPS = 24 * (1000/1001);	convertW = 720;	convertH = 480;	pulldownADV = true;	srcHasFields = false;	srcFieldDominance = 1;	else if (srcClip == 6) // "VGA"	srcFPS = 24;	convertW = 640;	convertH = 480;	srcHasFields = false;	srcFieldDominance = 0;else if (srcClip == 7) // SONY MPEG	srcFPS = 25;	convertW = 640;	convertH = 480;	srcHasFields = false;	srcFieldDominance = 0;else if (srcClip == 8) // Canon AVI	srcFPS = 15;	convertW = 320;	convertH = 240;	srcHasFields = false;	srcFieldDominance = 0;else if (srcClip == 9)	// HD 1080i50	srcFPS = 50;	convertW = 1920;	convertH = 1080;	srcHasFields = true;	srcFieldDominance = 0;else if (srcClip == 10)	// HD 1080i60	srcFPS = 30 * (1000/1001);	convertW = 1920;	convertH = 1080;	srcHasFields = true;	srcFieldDominance = 0;else if (srcClip == 11)	// HD 720p23.98	srcFPS = 24 * (1000/1001);	convertW = 1280;	convertH = 720;	srcHasFields = true;	srcFieldDominance = 0;else if (srcClip == 12)	// HD 720p24	srcFPS = 24;	convertW = 1280;	convertH = 720;	srcHasFields = false;	srcFieldDominance = 0;end ifif (fps == 30 && fieldProcessing) // && srcFPS == 30 * (1000/1001))	destFPS = srcFPS; 	// correct for the only occurance of 29.97 in FXScript	destFPS = 30 * (1000/1001); 	// correct for the only occurance of 29.97 in FXScriptend ifif fps == 24 && srcClip == 24 * (1000/1001)	srcClip = 24;end if	//pulldownDuration =  destFPS/gcd(srcFPS, destFPS);pulldownDuration = 1;pulldown = pulldownoffset/pulldownDuration// float pulldownDuration, pulldownMethod;// if (pulldown > 2 && pulldown < 8) 	pulldown = (pulldown + 1) % 5; 	pulldownDuration = 5; 	pulldownMethod = 1 // Standard 3:2 pulldown // else if (pulldown > 8 && pulldown < 14)// 	pulldown = (pulldown - 9 ) % 5 + 1;// 	pulldownDuration = 5;	// 	pulldownMethod = 2 // Advanced 3:2 pulldown// // // else if (pulldown > 14 && pulldown < 18)// 	pulldown = (pulldown - 15 ) % 3 + 1;// 	pulldownDuration = 3;// 	pulldownMethod = 2 // SONY MPEG 2/3 playback correction// // else// 	pulldownDuration = 1;// 	pulldownMethod = 0;// 	 end if// float threshold, soften;color debugColor;point ybox[4], srcbox[4], frameBox[4],frameBoxA[4], frameBoxB[4], halfBox[4], test[4], debugBox[4];dimensionsOf(dest, w, h);zoom = w/720;float Nw, Nh, clipDUR, clipOFFSET;srcFAR *= aspectOf(dest);fitWH = (fitWH + 1)/2; // turns this into a 0-1 decimal valueboundsOf(dest, frameBox);MakeRect(srcBox, convertW/-2, convertH/-2, convertW, convertH);makeRect(ybox, convertW/-2, convertW/srcFAR/-2, convertW, convertW/srcFAR); FastRotate(ybox, rotation, aspectOf(dest));mirrorRect(ybox, mirror-1&1, mirror > 2)scaleToFit(ybox, frameBox, ybox, fitWH, fitMethod);fitPoly(ybox, 4, frameBox, ybox, xshift, yshift);image img1[convertW][convertH], img2[convertW][convertH], img3[convertW][convertH];image infield1[convertW][convertH/2],  infield2[convertW][convertH/2], infield3[convertW][convertH/2];//	//	if (CLIPDUR == kundefined || CLIPDUR == 0); // check for cached data//		getLimits(convertclip, CLIPDUR, CLIPOFFSET);//	end if;getnativesize(convertclip, Nw, Nh);getLimits(convertclip, clipDUR, clipOFFSET);if (CLIPDUR > 0) // there is a clip to work with...	// translate maskDetail values	threshold = maskDetail * 0.4 + 8;	soften = threshold/4//	getFrame = frame/(fieldprocessing + 1) * (srcFPS/destFPS)  + pulldown;	// selected frame of source clip//	getFrame = frameFix/(fieldprocessing + 1) * (srcFPS/destFPS)  + pulldown;	// selected frame of source clip	getFrame = frame * (srcFPS/destFPS) // + pulldown;	// selected frame of source clip	if (pulldownSTD); 	//	getFrame += pulldown; 	end if		theField = (getFrame - integer(getFrame) < 0.5) ? 0 : 1;	// select first or second temporal field (not spatial)		if (pulldownSTD) // 24p standard pulldown needs to be removed		srcHasFields = false; // set to progressive for frame count but set field dominance for split-frame reconstruction		s24p = getFrame; 		// need to make sure 23.98 and 24p don't conflict...		// temp dubug for 24fps timelines:		//s24p = frameFix;			//	getFrame = (integer(s24p) * destFPS/srcFPS); 		getFrame = s24p * (destFPS/srcFPS); 	//	getFrame = (integer(s24p) * (1001/1000 * 30)/ (1001/1000 * 24)); // does the same as above but stupidly hardcoded		//getFrame -= integer((pulldownoffset  + 1 - s24p % 4)/4);//		getFrame -= (pulldownoffset  + 1 - s24p % (pulldownDuration-1))/(pulldownDuration-1));//	getFrame += pulldownDuration/pulldownDuration;					//		getFrame += 0.00005;	// ugh, I hate this...			if (integer(s24p) % 4 != (pulldownoffset + 1) % 4)	//		getFrame += integer((s24p % 4 + 2 - pulldownoffset) / 4 );			end if	end if		if (pulldownADV) // 24p advanced pulldown				srcFPS = 30 * (1000/1001);			getFrame = frame * (srcFPS/destFPS) 							if (floor(getFrame) % pulldownDuration == pulldownoffset)				getFrame +=1;			end if					end if					nextClosest = (getFrame - integer(getFrame) < 0.5) ? -1 : 1; //  direction of next closest correct field, getVideo( -n) returns frame 0	GetVideo(convertclip, integer(getFrame) + CLIPOFFSET, img1);		boundsOf(img1, frameBoxA);	boundsOf(infield1, halfbox);	frameBoxB = frameBoxA;	if (!srcHasFields)		// Progressive Source Clip && Progressive OR interlaced output									debugColor = {255, 128, 0, 0};	// maroon									if (pulldownSTD && (integer(s24p) % 4 == (pulldownoffset + 1) % 4)) // 24p standard pulldown split frame						getFrame += integer((s24p % 4 + 2 - pulldownoffset) / 4 );			// existing frame already has correct second field, blit in correct first field from next frame			GetVideo(convertclip, integer(getFrame) + CLIPOFFSET + 1, img2);					srcFieldDominance ^=1;				for j = frameBoxA[0].y to frameBoxA[3].y step 2									frameBoxB[0].y = j + srcFieldDominance;				frameBoxB[1].y = j + srcFieldDominance;				frameBoxB[2].y = j + 1 + srcFieldDominance;				frameBoxB[3].y = j + 1 + srcFieldDominance;							//	BlitRect(img2, frameBoxB, img1, frameBoxB);					next;			debugColor = {255, 0, 0, 255};	// blue		end if				BlitRect(img1, frameBoxA, dest, ybox);			if (floor(getFrame-1) % pulldownDuration == pulldownoffset)					debugColor = {255, 255, 125, 0};	// orange			end if			else // Interlaced source		if (fieldprocessing)	// Interlaced Sequence (Interlaced Source Clip)			if (destField == theField)	// fields match send selected field 												DeInterlaceFast(img1, img1, theField ^ srcFieldDominance);				boundsOf(img1, frameBoxA);				BlitRect(img1, frameBoxA, dest, ybox); 				debugColor = {255, 255, 255, 0}; // yellow			else	// field mismatch										DeInterlaceFast(img1, img2, theField ^ srcFieldDominance);	// temporally correct field				DeInterlaceFast(img1, inField1, theField ^ srcFieldDominance ^ 1);	// alternate spatially correct field				//	getField(convertclip, integer(getFrame + nextClosest) + CLIPOFFSET, inField2, convertW, convertH, theField ^ srcFieldDominance ^ 1); // get closest second alternate field// will re-enable that and delete the following lines once I figure out why getField is returning a wrong/munged field				if ((getFrame + nextClosest) < 0)						DeInterlaceFast(img1, inField2, theField ^ srcFieldDominance);	// alternate spatially correct field				else						getVideo(convertclip, integer(getFrame + nextClosest) + CLIPOFFSET, img3); // get closest second alternate field						DeInterlaceFast(img3, inField2, theField ^ srcFieldDominance ^ 1);	// alternate spatially correct field				end if				DifferenceMask(inField1, inField2, img2, threshold, 1, soften);				matte(img2, img1, img1, ffblend/100, kalpha);				boundsOf(img1, frameBoxA);				BlitRect(img1, frameBoxA, dest, ybox); 				// add the following back in to save motion difference processing when it's invisible				//if (((ffblend < 100) && (integer(getFrame) != integer(getFrame2))) || motionDiff)				debugColor = {255, 255, 0, 255};	// magenta			end if		else 	// Progressive Sequence (Interlaced Source Clip)						DeInterlaceFast(img1, img2, theField ^ srcFieldDominance);	// temporally correct field				DeInterlaceFast(img1, inField1, theField ^ srcFieldDominance ^ 1);	// alternate spatially correct field				//	getField(convertclip, integer(getFrame + nextClosest) + CLIPOFFSET, inField2, convertW, convertH, theField ^ srcFieldDominance ^ 1); // get closest second alternate field// will re-enable that and delete the two following lines once I figure out why getField is returning a wrong/munged field				if ((getFrame + nextClosest) < 0)						DeInterlaceFast(img1, inField2, theField ^ srcFieldDominance);	// alternate spatially correct field				else						getVideo(convertclip, integer(getFrame + nextClosest) + CLIPOFFSET, img3); // get closest second alternate field						DeInterlaceFast(img3, inField2, theField ^ srcFieldDominance ^ 1);	// alternate spatially correct field				end if								if (getFrame - integer(getFrame) < 0.25)					// get previous field 2					blendopacity = (getFrame - integer(getFrame)) * 2 + 0.5;									else if (getFrame - integer(getFrame) >= 0.25) && (getFrame - integer(getFrame) < 0.75)					//blend fields from single, selected frame					blendopacity = (getFrame - integer(getFrame) - 0.25) * 2;									else if (getFrame- integer(getFrame) >= 0.75)					// get next field 1					blendopacity = (getFrame - integer(getFrame) - 0.25) * 2 -1;				end if				if blendopacity > 0.5					blendopacity = 1 - blendopacity;				end if								blendOpacity = 0.5												boundsOf(infield1, frameBoxA);								boundsOf(img2, frameBoxB);								if ((getFrame - integer(getFrame) >= 0.25) && (getFrame - integer(getFrame) < 0.75)) // blend infiield 1								BlitRect(infield1, frameBoxA, img3, frameBoxB); 				else  // blend infield2								BlitRect(infield2, frameBoxA, img3, frameBoxB); 				end if												matte(img3, img2, img2, blendopacity, kalpha);								DifferenceMask(inField1, inField2, img2, threshold, 1, soften);				matte(img2, img1, img1, ffblend/100, kalpha);				boundsOf(img1, frameBoxA);				BlitRect(img1, frameBoxA, dest, ybox); 					debugColor = {255, 127, 255, 255*(theField^1)};		// green/aqua				end if	end ifend ifif showmask  		if (GetPixelFormat(dest) == kFormatYUV219)  			channelcopyfit(img2, dest, knone, kalpha, knone, knone); 			channelfill(dest, 255, -1, 127, 127);  		else			channelcopyfit(img2, dest, knone, kalpha, kalpha, kalpha); 			channelfill(dest, 255, -1, -1, -1); 		end ifend if	if (showspot) // show debug blocks		makeRect(test, w/2 - 50, h/2 - 50, 50, 50); 		fillPoly(test, dest, debugColor);		end if;	if (showboxes)	boundsOf(dest, test);									ybox *= 0.5;	test *= 0.5;	FramePoly(test, dest, kblack, 3);	FramePoly(ybox, dest, kblack, 3);	FramePoly(test, dest, kgray, 2);	FramePoly(ybox, dest, kwhite, 2);end ifif (showvals)	float aaa;		aaa = -h/2 * (frame&1^1); // used to toggle reported values			if (destFPS == 30 * (1000/1001))//		destFPS = 60;	end if	if (srcFPS == 24 * (1000/1001))//		srcFPS = 24;	end if		if (srcFPS == 30 * (1000/1001))//		srcFPS = 60;	end if		if (srcFPS == 25 && srcHasFields == true)//		srcFPS = 50;	end if				channelMultiply(dest, dest, 1, q, 1,1);		numReporter(dest, frame, "frame", kfloat2, h/2*0.1 + aaa, 28, 1);	numReporter(dest, getFrame, "getFrame", kfloat6, h/2*0.2 + aaa, 28, 1);	numReporter(dest, s24p, "s24p", kfloat6, h/2*0.3 + aaa, 28, 1);	numReporter(dest, destFPS, "destFPS", kfloat6, h/2*0.4 + aaa, 28, 1);	numReporter(dest, srcFPS, "srcFPS", kfloat6, h/2*0.5 + aaa, 28, 1);//	numReporter(dest, 30 * (1000/1001), "30 * (1000/1001)", kfloat6, h/2*0.5 + aaa, 28, 1);	numReporter(dest, pulldownOffset/pulldownDuration, "pulldownOffset/pulldownDuration", kfloat4, h/2*0.6 + aaa, 28, 1);//	numReporter(dest, pulldownoffset/(pulldownDuration-1), "pulldownoffset/(pulldownDuration-1)", kfloat4, h/2*0.7 + aaa, 28, 1);		numReporter(dest, s24p * (destFPS/srcFPS), "s24p * (destFPS/srcFPS);", kfloat6, h/2*0.7 + aaa, 28, 1);	numReporter(dest, getFrame % pulldownDuration, "getFrame % pulldownDuration", kfloat4, h/2*0.8 + aaa, 28, 1);//	numReporter(dest, (getFrame + 1 + pulldownOffset) % pulldownDuration - (getFrame + pulldownOffset) % pulldownDuration, "pulldown loop", kfloat4, h/2*0.8 + aaa, 28, 1);//	numReporter(dest, gcd(srcFPS, destFPS), "gcd(srcFPS, destFPS)", kfloat2, h/2*0.9 + aaa, 28, 1);//	numReporter(dest, destFPS/gcd(srcFPS, destFPS), "30/gcd(srcFPS, destFPS)", kfloat2, h/2 + aaa, 28, 1);		//	numReporter(dest, sourceDuration, "sourceDuration", kfloat2, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, destField, "destField", kfloat2, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, s24p, "s24p", kfloat4, h/2*0.2 + aaa, 28, 1);//	numReporter(dest, thisframe, "thisframe", kfloat4, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, nextframe, "nextframe", kfloat4, h/2*0.5 + aaa, 28, 1);//	numReporter(dest, getFrame2, "getFrame2", kfloat2, h/2*0.3 + aaa, 28, 1);//	numReporter(dest, getFrame + pulldownoffset/pulldownDuration, "getFrame+ pulldownoffset/pulldownDuration", kfloat2, h/2*0.3 + aaa, 28, 1)//	numReporter(dest, getFrame*2/2 - integer(getFrame * 2)/2, "(getFrame*2/2 - integer(getFrame * 2)/2", kfloat2, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, integer((pulldownoffset  + 1 - s24p % 4)/4), "int((pulldownoffset+1-s24p%4)/4)", kfloat2, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, destField, "destField", kfloat2, h/2*0.4 + aaa, 28, 1);//	numReporter(dest, theField, "theField", kfloat2, h/2*0.5 + aaa, 28, 1);//	numReporter(dest, nextClosest, "nextClosest", kfloat2, h/2*0.6 + aaa, 28, 1);			if (theField != destField)		if (integer(getFrame) != integer(getFrame2))			if (getFrame*2/2 - integer(getFrame * 2)/2) < 0.25//				numReporter(dest, -1, "BEFORE", kfloat2, h/2*0.9 + aaa, 28, 1);;			else//				numReporter(dest, 1, "AFTER", kfloat2, h/2*0.9 + aaa, 28, 1);			end if		end if	end ifend if