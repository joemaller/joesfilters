filter "SUBROUTINE ROTATER!"group "BETA"input srcW, "Convert Width", slider, 320, 200, 1000;input srcH, "Convert Height", slider, 240, 200,  1000;	// used only for BLIT source calculationsinput srcFAR, "Frame Aspect Ratio", popup, 4, "1:1", "1.33:1 (4:3)", "1.55:1 (14:9)","1.66:1 (5:3)", "1.77:1 (16:9)", "2:1", "2.35:1 (47:20)", "0.5625:1 (9:16)";//input rotater, "Orientation:", Popup, 1, "0¡ (No rotation)", "90¡ Clockwise", "90¡ Counter-Clockwise", "180¡", "Flip Horizontal", "Flip Vertical";input rotation, "Rotate:", angle, 0, -360, 360;input mirror, "Mirror:", popup, 1, "none", "Mirror Horizontal", "Mirror Veritcal", "Mirror Both"; input l0, "Fitting", label, "";input fitMethod, "Fit:", Popup, 1, "Width  <-> Height", "Width  <-> Original", "Height <-> Original";input fitWH, "Fitting", Slider, 0, -1, 1 detent -1, 0, 1;input xshift, "Pan (Horz Adj)", slider, 0, -100,  100 label "%";input yshift, "Scan (Vert Adj)", slider, 0, -100,  100 label "%";codeon RotateCorners(point _box, value _rotater)	// switches corners to simulate rotation prior to blit'ing		if ( _rotater != 1)		point _rotatetemp[4];		float _j;					_rotatetemp = _box;				if (_rotater < 5)			_rotater = (_rotater < 4) ? (_rotater * 2 - 5) * -1 : _rotater/2;						for _j = 0 to 3				_box[_j] = _rotatetemp[(_j + 4 + _rotater) % 4];			next;					else if (_rotater == 5) // do flip horizontal				for _j = 0 to 3				_box[_j] = _rotatetemp[_j^1];			next;			else if (_rotater == 6) // flip vertical					for _j = 0 to 3				_box[_j] = _rotatetemp[3-_j];			next;				end if		end ifendon NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)		float rw, rh, ra, rd, rzoom;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	fontcolor = {255,255,124,0};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(kcenterjustify);	setTextSize(_fontsize * rzoom);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));endon BoundsOfPoly(point _srcPoly, value _srcPolyPts, point _destRect)		// returns the rectangular bounding box of n-sided polys		// _srcPoly 		: 		polygon to fit inside _destRect	// _srcPolyPts 		: 		number of points in _srcPoly, because it can't be programatically determined	// _destRect		:		four-point poly which receives the bounding box around _srcPoly	float _j;	point _topLeft, _bottomRight;		_topLeft = _srcPoly[0];	_bottomRight = _srcPoly[2];		repeat with _j = 0 to ( _srcPolyPts -1)			if (_srcPoly[_j].x < _topLeft.x)			_topLeft.x = _srcPoly[_j].x;		else if (_srcPoly[_j].x > _bottomRight.x)			_bottomRight.x = _srcPoly[_j].x;		end if		if (_srcPoly[_j].y < _topLeft.y)							_topLeft.y = _srcPoly[_j].y;		else if (_srcPoly[_j].y > _bottomRight.y)			_bottomRight.y = _srcPoly[_j].y;		end if	end repeat	//makeRect(_destRect, _topLeft.x, _topLeft.y, abs(_topLeft.x) + abs(_bottomRight.x), abs(_topLeft.y) + abs(_bottomRight.y));	makeRect(_destRect, _topLeft.x, _topLeft.y, _bottomRight.x - _topLeft.x, _bottomRight.y - _topLeft.y);end	on DimensionsOfPoly(point _srcPoly, value _srcPolyPts, point _WH)		// returns the maximum  Width/Height of n-sided polys 			// _srcPoly 		: 		polygon to fit inside _destRect	// _srcPolyPts 		: 		number of points in _srcPoly, because it can't be programatically determined	// _WH			:		a single point used to return two float values, x = Width, y = Height	float _j;	point _topLeft, _bottomRight;		_topLeft = _srcPoly[0];	_bottomRight = _srcPoly[2];		repeat with _j = 0 to ( _srcPolyPts -1)			if (_srcPoly[_j].x < _topLeft.x)			_topLeft.x = _srcPoly[_j].x;		else if (_srcPoly[_j].x > _bottomRight.x)			_bottomRight.x = _srcPoly[_j].x;		end if		if (_srcPoly[_j].y < _topLeft.y)							_topLeft.y = _srcPoly[_j].y;		else if (_srcPoly[_j].y > _bottomRight.y)			_bottomRight.y = _srcPoly[_j].y;		end if	end repeat	_WH.x = abs(_topLeft.x) + abs(_bottomRight.x);	_WH.x = _bottomRight.x - _topleft.x;	_WH.y = _bottomRight.y - _topleft.y;//	NumReporter(dest, _WH.x, "_polyW", kfloat2, destH/2 * -0.2, 32, 1);//	NumReporter(dest, _WH.y, "_polyH", kfloat2, destH/2 * -0.3, 32, 1);	end	on scaleToFit(point _srcRect, point _frameRect, point _destRect, value _scaler, value _fitMethod)	// scales the original frame by 1 of 3 scaling ranges	// _srcRect		: 	Original Frame Box	// _frameRect	:	destination frame box	// _destRect	: 	destination for scaled box results		// 1 = Fit width <-> height	// 2 = Fit width <-> original	// 3 = Fit height <-> original		point _fit	DimensionsOfPoly(_srcRect,  4,  _fit)				_fit.x = (_frameRect[1].x - _frameRect[0].x)/_fit.x;	_fit.y = (_frameRect[3].y - _frameRect[0].y)/_fit.y;				if 		(_fitMethod == 1); 	_scaler = _scaler * (_fit.y - _fit.x) + _fit.x;		// W H	else if 	(_fitMethod == 2);	_scaler = _scaler * (1 - _fit.x) + _fit.x;		// W O	else if 	(_fitMethod == 3);	_scaler = _scaler * (1 - _fit.y) + _fit.y;		// H O	end if	_destRect = _srcRect;	_destRect *= _scaler;		endon fitRect(point _srcRect, point _frameRect, point _destRect, value _hshift, value _vshift)	// essentially this is a pan/scan tool, fitRect places one rectangle inside another rectangle	// fitting values are -100 - 100 percentage values used to place _srcRect when sizes differ	// the new rectangle is placed in _destRect	// source rectangles are moved around until they align with the dest frame's edges 			point _box, _frame;	DimensionsOfPoly(_srcRect, 4, _box);	DimensionsOfPoly(_frameRect, 4, _frame);	_hshift /= (_box.x > _frame.x) ? 100 : -100;		//adjust perceived direction shifts	_vshift /= (_box.y > _frame.y) ? 100 : -100;	_hshift = ((_box.x - _frame.x) * _hshift)/2;	_vshift = ((_box.y - _frame.y) * _vshift)/2;	MakeRect(_destRect, _box.h/-2 + _hshift, _box.v/-2 + _vshift, _box.h, _box.v);endon fitPoly(point _srcPoly, value _srcPolyPts, point _frameRect, point _destRect, value _hshift, value _vshift)	// a pan/scan tool used to place a multi-sided poly inside frame rectangle with offset	// fitting values are -100 - 100 percentage values used to place _srcRect when sizes differ	// the new rectangle is placed in _destRect	// source rectangles are moved around until they align with the dest frame's edges 			point _box, _frame;	float _j;	DimensionsOfPoly(_srcPoly, _srcPolyPts, _box);	DimensionsOfPoly(_frameRect, 4, _frame);	_hshift /= (_box.x > _frame.x) ? 100 : -100;		//adjust perceived direction shifts	_vshift /= (_box.y > _frame.y) ? 100 : -100;	_hshift = ((_box.x - _frame.x) * _hshift)/2;	_vshift = ((_box.y - _frame.y) * _vshift)/2;	///MakeRect(_destRect, _box.h/-2 + _hshift, _box.v/-2 + _vshift, _box.h, _box.v)		_destRect = _srcPoly;	for _j = 0 to 3		_destRect[_j].x += _hshift;		_destRect[_j].y += _vshift;	next;	endon FastRotate(point _srcPoly, value _rotation, value _aspect)	// a quick tool for rotating a polygon around a centerpoint.	// saves the step of having to define an extra point variable and call the centerOf function first	point _centerPt;	centerOf(_srcPoly, _centerPt);	Rotate(_srcPoly, _centerPt, _rotation, _aspect)endon mirrorRect(point _srcRect, value _flip)	// mirror a rectangular area	// 1 = flip horizontal	// 2 = flip vertical	// 3 = flip both	// other values return _srcBox unchanged	float _j;	point _rotatetemp[4];		_rotatetemp = _srcRect;		if (_flip == 1) // flip horizontal		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[_j^1];		next;	else if (_flip == 2) // flip vertical		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[3-_j];		next;	else if (_flip == 3) // flip both		for _j = 0 to 3			_srcRect[_j] = _rotatetemp[(_j + 2) % 4];		next;	end ifendchannelfill(dest, 0, 0, 0, 0);float aspect, destW, destH;point frameBox[4], srcBox[4], destBox[4];dimensionsOf(dest, destW, destH);aspect = aspectOf(dest);if (srcFAR == 1); srcFAR = 1/1; end ifif (srcFAR == 2); srcFAR = 4/3; end ifif (srcFAR == 3); srcFAR = 14/9; end ifif (srcFAR == 4); srcFAR = 5/3; end ifif (srcFAR == 5); srcFAR = 16/9; end ifif (srcFAR == 6); srcFAR = 2/1; end ifif (srcFAR == 7); srcFAR = 47/20; end ifif (srcFAR == 8); srcFAR = 9/16; end ifsrcFAR *= aspect;	// correct srcFAR for output PARsrcH = srcW/srcFAR; fitWH = (fitWH + 1)/2; // turns this into a 0-1 decimal valueboundsOf(dest, frameBox);MakeRect(srcBox, srcW/-2, srcH/-2, srcW, srcH);// *** All that's needed to scale and pan/scan a rectangle:FastRotate(srcBox, rotation, aspectOf(dest));mirrorRect(srcBox, mirror-1)scaleToFit(srcBox, frameBox, destBox, fitWH, fitMethod);fitPoly(destBox, 4, frameBox, destBox, xshift, yshift);// ***boundsOf(dest, srcBox);BlitRect(src1, srcbox, dest, destBox)//framePoly(destBox, dest, kmagenta, 2);