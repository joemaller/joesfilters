filter "Count Array Test";group "FXScript Reference";input len, "len", slider, 8, 1, 1024 detent 2,4,8,16,32, 64,128, 256, 512, 1024;input n, "n", slider, 10, 0, 100input j, "j", slider, 1, 1, 100input steps, "steps", slider, 3, 1, 2000//input rseed, "rseed", slider, 0.1, -1, 1;input divi, "divi", slider, 1.5, 1, 3;input which, "which", checkbox, 0code// INCLUDE "PtReporter.fxscript"  v1.1on PtReporter(image _destIMG, point _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)		float rw, rh, ra, rd, rzoom;	string reporterX, reporterY;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(kcenterjustify);	setTextSize(_fontsize * rzoom);														NumToString(_data.x, reporterX, _numberformat);	NumToString(_data.y, reporterY, _numberformat);	reporterX = _label + " = {" + reporterX + "," + reporterY + "}";	DrawString(reporterX, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));end// END "PtReporter.fxscript"// INCLUDE "NumReporter.fxscript"  v1.1on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _tracking)		float rw, rh, ra, rd, rzoom;	string reporter;	color fontcolor;		DimensionsOf(_destIMG, rw, rh);	rzoom = rw/720;		fontcolor = {255,235,235,235};	settextfont("verdana");	setTextstyle(kbold);	setTextjustify(kcenterjustify);	setTextSize(_fontsize * rzoom);														NumToString(_data, reporter, _numberformat);	reporter = _label + " = " + reporter;	DrawString(reporter, 0, _h, _tracking,  _destIMG, fontcolor, aspectof(_destIMG));end// END "NumReporter.fxscript"on max(value _a, value _b); return (_a > _b) ? _a : _b; endon min(value _a, value _b); return (_a < _b) ? _a : _b; end on ceil(value _x); return(((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x)); end on floor(value _x); return(((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x)); end // INCLUDE "round.fxscript"  v1.1on round(value _x, value _precision)	// rounding function with decimal precision		_x *= power(10, _precision)		if (_x > 0) 		_x = (_x - integer(_x)  >= 0.5) ? _x = ceil(_x) : floor(_x);	else		_x = (_x - integer(_x)  <= -0.5) ? _x = floor(_x) : ceil(_x);	end if	return _x/(power(10, _precision));end// END "round.fxscript"on count(float _ar, value _current)		float  _max, _checked[1024];	// 1024 is an arbitrary maximum length	randomseed(0);	randomtable(_ar);	_checked *= 0;		repeat while (true) 		if(_current >= 0 && !_checked[_current])			_checked[_current] = 1;			_max = max(_max, _current);			_current = (_ar[_current] > _current) ? _ar[_current] : _current--		else if (_current > 0 && _checked[_current])			_current--		else			return _max;		end if	end repeatend// something strange going on tonight...// in some recursive calls, blatant syntax errors will be ignored and returned as huge negative numbers// trying to isolate that:on RecurseError(value _x)	if _x > 0		return _x + (_x - RecurseError(_x-1));	end ifendfloat Gcount;on counter(float _a, value _z)	numreporter(dest, _z, "_z", kfloat2, _z*5, 30, 1.25);	Gcount++;//	if (_a[_z+10] != -1234567890.987654321)		if Gcount < 18			_z =  counter(_a, _z+10);		return _z 	 	end ifendon counter2b(float _ar)	float _x;	repeat while indexExists(_x++, _ar)	end repeat;	return _x;end// INCLUDE "countFloatArray.fxscript"  v1.1on indexExists(value _i, float _ar);return(_ar[_i]!=kundefined); end on countFloatArray(float _ar)	float _l, _r, _seed, _step, _counter;	_seed = 7; // somewhat arbitrary, chosen after a lot of performance testing	_step = _seed;		_l = 1 // set this to save a loop checking the zeroth index	_r = _l + _seed;	repeat while true		_counter++;		if (indexExists(_l, _ar) && indexExists(_r, _ar))	// both values in array			_l = _r+1;	// start at _r+1 to prevent double-checking values			_r = _l + _step;			_step += _seed * _counter;		else if (!indexExists(_l, _ar) && !indexExists(_r, _ar))	// no values in array			return _l;	// stepped one over _r previously, last index must be _l-1, return _l to compenstate for count vs. index off-by-one		else 	// bottom value in array, top not. Half top and step bottom			_step = _r; // temporary storage of the _r variable			_l = _l+1; // increment _l to prevent double-checking values			_r = _l + integer((_r - _l)/2);	// half the distance between _l and _r			_step -= _r; // difference between old _r and new _r		end if	end repeat;end// END "countFloatArray.fxscript"// INCLUDE "countPtArray.fxscript"  v1.3on indexExistsPt(value _i, point _ar);return(_ar[_i] == true); endon countPtArray(point _ar)	float _l, _r, _seed, _step, _counter;	_seed = 7; // somewhat arbitrary, chosen after lots of performance testing	_step = _seed;	// store seed for later	 	_l = 1 // set this to save a loop checking the zeroth index	_r = _l + _seed;	repeat while true		_counter++;		if (indexExistsPt(_l, _ar) && indexExistsPt(_r, _ar))	// both values in array			_l = _r+1;	// start at _r+1 to prevent double-checking values			_r = _l + _step;			_step += _seed * _counter;		else if (!indexExistsPt(_l, _ar) && !indexExistsPt(_r, _ar))	// no values in array			return _l;	// stepped one over _r previously, last index must be _l-1, return _l to compenstate for count vs. index off-by-one		else 	// bottom value in array, top not. Half top and step bottom			_step = _r; // temporary storage of the _r variable			_l = _l+1; // increment _l to prevent double-checking values			_r = _l + integer((_r - _l)/2);	// half the distance between _l and _r			_step -= _r; // difference between old _r and new _r		end if	end repeat;end// END "countPtArray.fxscript"float k, now, total, tmax;channelfill(dest, 255, 0, 0, 0);float ar[len];point arPt[len]point box[len/2]	ar += 15;//arPt += 15tmax = 0;	//repeat with k = 1 to j//	now = count(ar, tmax);//	total += now//	tmax = max(tmax,now);//	numreporter(dest, now, "count(ar);", kfloat2, k/j * 120, 30, 1.25);//end repeat////numreporter(dest, total/j, "average", kfloat2, -15, 30, 1.25);////numreporter(dest, tmax, "tmax", kfloat2, -25, 30, 1.25);//numreporter(dest, counter2b(ar), "counter2(ar)", kfloat2, -95, 30, 1.25);//numreporter(dest, GCount, "GCount", kfloat2, -75, 30, 1.25);numreporter(dest, countFloatArray(ar), "countFloatArray(ar)", kfloat2, -85, 30, 1.25);numreporter(dest, countPtArray(arPt), "countPtArray(arPt)", kfloat2, -65, 30, 1.25);//	numreporter(dest, countPtArray(box), "countPtArray(box)", kfloat2, -45, 30, 1.25);//numreporter(dest, RecurseError(n), "RecurseError(n)", kfloat2, -60, 30, 1.25);on undefinedTest1(float _ar)	return (_ar[10] != kundefined)endfloat ar5[5], ar50[50]//numreporter(dest, undefinedTest1(ar5), "undefinedTest1(ar5)", kfloat2, 60, 30, 1.25);//numreporter(dest, undefinedTest1(ar50), "undefinedTest1(ar50)", kfloat2, 70, 30, 1.25);indexExists(-10, ar)// what would happen if the skipping value started small and incremented exponentially?// wouldn't that result in better low-number results as well as nailing high values faster?// write a quick  PHP script to step through a given number of indices, average them// and compare for a variety of divisors.