filter "extend frame"
group "BETA FUNCTIONS";




input method, "Method", RadioGroup, 1, "Wrap Around", "Mirror Edges";
input frameScaler, "FrameScaler", Slider, 1.75, 1, 4;

input cropper, "cropper", Slider, 1, 0.1, 1;



code





on extendFrame(image _src, image _dest, value _edges, value _crop)
		
		// REQUIRES: MirrorRect
		
		// need to build in an option to trim in on the source frame to clip messy edges
		// that would just scale the initial box and sample from a smaller source frame
		
		// _edges: (matches RadioGroup input)
		//		1: wrap around
		//		3: 8 tiles	(8 blits)

		// _crop is a percentage of the frame to crop in
		
		// this works, but there are several rounds of optimization left to do:
		//	1. Truncate both boxes to only copy the visible result. Will require some logic to determine when  one box exceeds the other
		//	2. Second row is a copy of the first row. Copy larger areas to save blits.
		//	 		example based on calculator keypad: 
		//			copy 4 7 & 8. 9 & 6 are a copy of 4 & 7, saving one blit
		//			1,2 & 3 are a copy of 7, 8 & 9, saving two blits.
		
		// currently only supports extending frames by up to 300% (two full frames added to each dimension)
		
	point _srcBox[4], _destBox[4], _inBox[4], _outBox[4], _shifter;
	BoundsOf(_src, _srcBox);
	BoundsOf(_dest, _destBox);
	
	_srcBox *= _crop;

	if (_srcBox[2] == _destBox[2])
		_dest = _src;
	else 
		BlitRect(_src, _srcBox, _dest, _srcBox);

		_shifter = {0, (_srcBox[3].y - _srcBox[0].y)} //	vertical shift
		_outBox = _srcBox;
		_outBox -= _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 0, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		if (_edges == 1)	// wrap edges, start opposite side
			MakeRect(_inBox, _srcBox[2].x, _srcBox[2].y, -(_srcBox[3].x - _destBox[0].x), -(_srcBox[3].y - _destBox[0].y));
			_shifter = {_srcBox[0].x - _srcBox[1].x, 0}
		else 
			MakeRect(_inBox, _srcBox[3].x, _srcBox[3].y, (_srcBox[3].x - _destBox[0].x), -(_srcBox[3].y - _destBox[0].y));
			_shifter = {_inBox[0].x - _inBox[1].x, 0}
		end if
		_outBox = _inBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_inBox, 1, 0);
		end if
		
		BlitRect(_dest, _inBox, _dest, _outBox);
		
		if (_edges == 1)	// wrap edges, start opposite side
			MakeRect(_inBox, _srcBox[3].x, _srcBox[3].y, (_destBox[1].x - _srcBox[1].x), -(_srcBox[2].y - _destBox[1].y));
			_shifter = {_srcBox[1].x - _srcBox[0].x, 0}
		else 
			MakeRect(_inBox, _srcBox[2].x, _srcBox[2].y, -(_destBox[2].x - _srcBox[2].x), -(_srcBox[2].y - _destBox[1].y));
			_shifter = {_inBox[0].x - _inBox[1].x, 0}
		end if
		
		_outBox = _inBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_inBox, 1, 0);
		end if
		
		BlitRect(_dest, _inBox, _dest, _outBox);
		
		if (_edges == 1)	// wrap edges, start opposite side
			MakeRect(_inBox, _destBox[0].x, _srcBox[0].y, (_destBox[1].x - _destBox[0].x), (_srcBox[1].y - _destBox[1].y));
			_shifter = {0, _srcBox[3].y - _srcBox[0].y}
		else
			MakeRect(_inBox, _destBox[0].x, _srcBox[3].y, (_destBox[1].x - _destBox[0].x), -(_srcBox[1].y - _destBox[1].y));
			_shifter = {0 ,_inBox[0].y - _inBox[3].y}
		end if
		
		_outBox = _inBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_inBox, 0 , 1);
		end if
		BlitRect(_dest, _inBox, _dest, _outBox);

		
	end if


end




// INCLUDE "mirrorRect.fxscript" r50

on mirrorRect(point _srcRect, value _flipX, value _flipY)
	// mirror a rectangular area
	// _flipX and _flipY are booleans
	
	float _j;
	point _rotatetemp[4];
	
	_rotatetemp = _srcRect;
	
	if (_flipX && !_flipY) // flipX
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[_j^1];
		next;
	else if (_flipY && !_flipX) // flip vertical
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[3-_j];
		next;
	else if (_flipX && _flipY) // flip both
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[(_j + 2) % 4];
		next;
	end if
end

// END "mirrorRect.fxscript"






// INCLUDE "ChannelCopyFit.fxscript" r49

on ChannelCopyFit(image _src, image _dest, value _A, value _R, value _G, value _B)
	// a combination of channelcopy and blitrect, scales any specified channel to fit the target
	// specifically for cases where a channel source is not the same size as the channel destination
	// _A, _R, _G & _B work just like Channelcopy and are of the set {kalpha, kred, kgreen, kblue}
	// This is meant to be a more versatile drop-in replacement for ChannelCopy
	
	point _srcBox[4], _destBox[4];
	boundsOf(_src, _srcBox);
	boundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		// sizes are equal, normal channelcopy...
		channelCopy(_src, _dest, _A, _R, _G, _B);

	else	// sizes are unequal, do blit then channel
		
		
		//		check for size differences
		// 		do channelcopy on larger image to preserve resolution 
				
		if (_srcBox[2].x * _srcBox[2].y < _destBox[2].x * _destBox[2].y)	// _src is smaller than _dest
			image _temp[_destBox[1].x - _destBox[0].x][_destBox[3].y - _destBox[0].y]; // create second dest-sized image buffer
			blitRect(_src, _srcBox, _temp, _destBox);
			channelCopy(_temp, _dest, _A, _R, _G, _B);
		
		else // _src is larger than _dest
			image _temp[_srcBox[1].x - _srcBox[0].x][_srcBox[3].y - _srcBox[0].y]; // create second src-sized image buffer
			blitRect(_dest, _destBox, _temp, _srcBox);
			channelCopy(_src, _temp, _A, _R, _G, _B);
			blitRect(_temp, _srcBox, _dest, _destBox);
		
		end if
	end if
end

// END "ChannelCopyFit.fxscript"


float w, h;
DimensionsOf(dest, w, h);
image img0[w*frameScaler][h*frameScaler];


extendFrame(src1, img0, method, cropper);
ChannelCopyFit(img0, dest, kalpha, kred, kgreen, kblue);