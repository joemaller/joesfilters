filter "extend frame"
group "BETA FUNCTIONS";




input method, "Method", RadioGroup, 1, "Wrap Around", "Stretch to Corners", "Tile Corners";
input doCorners, "do corners", Checkbox, 1;



code





on extendFrame(image _src, image _dest, value _edges)
	
		// REQUIRES: FastRotate
		
		// need to build in an option to trim in on the source frame to clip messy edges

		// _edges: (matches RadioGroup input)
		//		1: wrap around
		//		2: stretch to corners (4 stretched blits)
		//		3: 8 tiles	(8 blits)


	point _srcBox[4], _destBox[4], _outBox[4];
	BoundsOf(_src, _srcBox);
	BoundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		_dest = _src;
	else 
		BlitRect(_src, _srcBox, _dest, _srcBox);

		_outBox[0] = _srcBox[0];
		_outBox[1] = _srcBox[1];
		_outBox[2] = _destBox[1];
		_outBox[3] = _destBox[0];
		if (_edges == 1 || _edges == 3 )
			_outBox[2].x = _srcBox[1].x;
			_outBox[3].x = _srcBox[0].x;
			if (_edges == 1)
				//	fastRotate(_outBox, 180, aspectOf(dest));
				mirrorRect(_outBox, 0, 1);
			end if
			
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);

		_outBox[0] = _destBox[1];
		_outBox[1] = _srcBox[1];
		_outBox[2] = _srcBox[2];
		_outBox[3] = _destBox[2];
		if (_edges == 1 || _edges == 3 )
			_outBox[0].y = _srcBox[0].y;	
			_outBox[3].y = _srcBox[2].y;	
			if (_edges == 1)
				//	fastRotate(_outBox, 180, aspectOf(dest));
				mirrorRect(_outBox, 1, 0);
			end if
			
		end if		
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_outBox[0] = _destBox[3];
		_outBox[1] = _destBox[2];
		_outBox[2] = _srcBox[2];
		_outBox[3] = _srcBox[3];
		if (_edges == 1 || _edges == 3 )
			_outBox[0].x = _srcBox[0].x;
			_outBox[1].x = _srcBox[1].x;
			if (_edges == 1)
				//	fastRotate(_outBox, 180, aspectOf(dest));
				mirrorRect(_outBox, 0, 1);
			end if
			
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);

		_outBox[0] = _srcBox[0];
		_outBox[1] = _destBox[0];
		_outBox[2] = _destBox[3];
		_outBox[3] = _srcBox[3];
		if (_edges == 1 || _edges == 3 )
			_outBox[1].y = _srcBox[0].y;	
			_outBox[2].y = _srcBox[2].y;	
			if (_edges == 1)
				//	fastRotate(_outBox, 180, aspectOf(dest));
				mirrorRect(_outBox, 1, 0);
			end if
			
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);


	end if


end




// INCLUDE "mirrorRect.fxscript" r50

on mirrorRect(point _srcRect, value _flipX, value _flipY)
	// mirror a rectangular area
	// _flipX and _flipY are booleans
	
	float _j;
	point _rotatetemp[4];
	
	_rotatetemp = _srcRect;
	
	if (_flipX && !_flipY) // flipX
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[_j^1];
		next;
	else if (_flipY && !_flipX) // flip vertical
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[3-_j];
		next;
	else if (_flipX && _flipY) // flip both
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[(_j + 2) % 4];
		next;
	end if
end

// END "mirrorRect.fxscript"



// INCLUDE "FastRotate.fxscript" r169

on FastRotate(point _srcPoly, value _rotation, value _aspect)
	// REQUIRES: CenterOfPoly
	
	// a quick tool for rotating a polygon around a centerpoint.
	// saves the step of having to define an extra point variable and call the centerOf function first
	point _centerPt;
	centerOfPoly(_srcPoly, _centerPt);
	Rotate(_srcPoly, _centerPt, _rotation, _aspect)
end

// END "FastRotate.fxscript"


// INCLUDE "ArrayPointCount.fxscript" r45

on indexExistsPt(value _i, point _ar);return(_ar[_i] == true); end

on ArrayPointCount(point _ar)
	float _l, _r, _seed, _step, _counter;
	_seed = 7; // somewhat arbitrary, chosen after lots of performance testing
	_step = _seed;	// store seed for later
	 
	_l = 1 // set this to save a loop checking the zeroth index
	_r = _l + _seed;

	repeat while true
		_counter++;

		if (indexExistsPt(_l, _ar) && indexExistsPt(_r, _ar))	// both values in array
			_l = _r+1;	// start at _r+1 to prevent double-checking values
			_r = _l + _step;
			_step += _seed * _counter;

		else if (!indexExistsPt(_l, _ar) && !indexExistsPt(_r, _ar))	// no values in array
			return _l;	// stepped one over _r previously, last index must be _l-1, return _l to compenstate for count vs. index off-by-one

		else 	// bottom value in array, top not. Half top and step bottom
			_step = _r; // temporary storage of the _r variable
			_l = _l+1; // increment _l to prevent double-checking values
			_r = _l + integer((_r - _l)/2);	// half the distance between _l and _r
			_step -= _r; // difference between old _r and new _r

		end if
	end repeat;
end

// END "ArrayPointCount.fxscript"


// INCLUDE "CenterOfPoly.fxscript" r60

on CenterOfPoly(point _poly, point _center)
	// requires arrayPointCount.fxscript
	
	float _x, _arLength;
	_arLength = arrayPointCount(_poly);
	_center = _poly[0];
	for _x = 1 to _arLength - 1
		_center += _poly[_x]
	next;
	_center /= _arLength
end

// END "CenterOfPoly.fxscript"



// INCLUDE "ChannelCopyFit.fxscript" r49

on ChannelCopyFit(image _src, image _dest, value _A, value _R, value _G, value _B)
	// a combination of channelcopy and blitrect, scales any specified channel to fit the target
	// specifically for cases where a channel source is not the same size as the channel destination
	// _A, _R, _G & _B work just like Channelcopy and are of the set {kalpha, kred, kgreen, kblue}
	// This is meant to be a more versatile drop-in replacement for ChannelCopy
	
	point _srcBox[4], _destBox[4];
	boundsOf(_src, _srcBox);
	boundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		// sizes are equal, normal channelcopy...
		channelCopy(_src, _dest, _A, _R, _G, _B);

	else	// sizes are unequal, do blit then channel
		
		
		//		check for size differences
		// 		do channelcopy on larger image to preserve resolution 
				
		if (_srcBox[2].x * _srcBox[2].y < _destBox[2].x * _destBox[2].y)	// _src is smaller than _dest
			image _temp[_destBox[1].x - _destBox[0].x][_destBox[3].y - _destBox[0].y]; // create second dest-sized image buffer
			blitRect(_src, _srcBox, _temp, _destBox);
			channelCopy(_temp, _dest, _A, _R, _G, _B);
		
		else // _src is larger than _dest
			image _temp[_srcBox[1].x - _srcBox[0].x][_srcBox[3].y - _srcBox[0].y]; // create second src-sized image buffer
			blitRect(_dest, _destBox, _temp, _srcBox);
			channelCopy(_src, _temp, _A, _R, _G, _B);
			blitRect(_temp, _srcBox, _dest, _destBox);
		
		end if
	end if
end

// END "ChannelCopyFit.fxscript"


float w, h;
DimensionsOf(dest, w, h);
image img0[w*1.75][h*1.75];


extendFrame(src1, img0, method);
ChannelCopyFit(img0, dest, kalpha, kred, kgreen, kblue);