filter "extend frame"
group "BETA FUNCTIONS";




input method, "Method", RadioGroup, 1, "Wrap Around", "Stretch to Corners", "Tile Corners";
input doCorners, "do corners", Checkbox, 1;



code





on extendFrame(image _src, image _dest, value _edges)
		
		// need to build in an option to trim in on the source frame to clip messy edges

		// _edges: (matches RadioGroup input)
		//		1: wrap around
		//		3: 8 tiles	(8 blits)

		// this works, but there are several rounds of optimization left to do:
		//	1. Truncate both boxes to only copy the visible result. Will require some logic to determine when  one box exceeds the other
		//	2. Second row is a copy of the first row. Copy larger areas to save blits.
		//	 		example based on calculator keypad: 
		//			copy 4 7 & 8. 9 & 6 are a copy of 4 & 7, saving one blit
		//			1,2 & 3 are a copy of 7, 8 & 9, saving two blits.
		
	point _srcBox[4], _destBox[4], _outBox[4], _shifter;
	BoundsOf(_src, _srcBox);
	BoundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		_dest = _src;
	else 
		BlitRect(_src, _srcBox, _dest, _srcBox);

		_shifter = {0, (_srcBox[3].y - _srcBox[0].y)} //	vertical shift
		_outBox = _srcBox;
		_outBox -= _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 0, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);

		_outBox = _srcBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 0, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_shifter = {(_srcBox[1].x - _srcBox[0].x), 0}; //	horizontal shift
		_outBox = _srcBox;
		_outBox -= _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 0);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);

		_outBox = _srcBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 0);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_shifter = {(_srcBox[1].x - _srcBox[0].x), (_srcBox[3].y - _srcBox[0].y)}; //	diagonal shift
		_outBox = _srcBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_outBox = _srcBox;
		_outBox -= _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_shifter = {(_srcBox[1].x - _srcBox[0].x), -(_srcBox[3].y - _srcBox[0].y)}; //	reverse diagonal shift
		
		_outBox = _srcBox;
		_outBox += _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		_outBox = _srcBox;
		_outBox -= _shifter;
		if (_edges == 2)
			mirrorRect(_outBox, 1, 1);
		end if
		BlitRect(_src, _srcBox, _dest, _outBox);
		
		
	end if


end




// INCLUDE "mirrorRect.fxscript" r50

on mirrorRect(point _srcRect, value _flipX, value _flipY)
	// mirror a rectangular area
	// _flipX and _flipY are booleans
	
	float _j;
	point _rotatetemp[4];
	
	_rotatetemp = _srcRect;
	
	if (_flipX && !_flipY) // flipX
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[_j^1];
		next;
	else if (_flipY && !_flipX) // flip vertical
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[3-_j];
		next;
	else if (_flipX && _flipY) // flip both
		for _j = 0 to 3
			_srcRect[_j] = _rotatetemp[(_j + 2) % 4];
		next;
	end if
end

// END "mirrorRect.fxscript"






// INCLUDE "ChannelCopyFit.fxscript" r49

on ChannelCopyFit(image _src, image _dest, value _A, value _R, value _G, value _B)
	// a combination of channelcopy and blitrect, scales any specified channel to fit the target
	// specifically for cases where a channel source is not the same size as the channel destination
	// _A, _R, _G & _B work just like Channelcopy and are of the set {kalpha, kred, kgreen, kblue}
	// This is meant to be a more versatile drop-in replacement for ChannelCopy
	
	point _srcBox[4], _destBox[4];
	boundsOf(_src, _srcBox);
	boundsOf(_dest, _destBox);

	if (_srcBox[2] == _destBox[2])
		// sizes are equal, normal channelcopy...
		channelCopy(_src, _dest, _A, _R, _G, _B);

	else	// sizes are unequal, do blit then channel
		
		
		//		check for size differences
		// 		do channelcopy on larger image to preserve resolution 
				
		if (_srcBox[2].x * _srcBox[2].y < _destBox[2].x * _destBox[2].y)	// _src is smaller than _dest
			image _temp[_destBox[1].x - _destBox[0].x][_destBox[3].y - _destBox[0].y]; // create second dest-sized image buffer
			blitRect(_src, _srcBox, _temp, _destBox);
			channelCopy(_temp, _dest, _A, _R, _G, _B);
		
		else // _src is larger than _dest
			image _temp[_srcBox[1].x - _srcBox[0].x][_srcBox[3].y - _srcBox[0].y]; // create second src-sized image buffer
			blitRect(_dest, _destBox, _temp, _srcBox);
			channelCopy(_src, _temp, _A, _R, _G, _B);
			blitRect(_temp, _srcBox, _dest, _destBox);
		
		end if
	end if
end

// END "ChannelCopyFit.fxscript"


float w, h;
DimensionsOf(dest, w, h);
image img0[w*1.75][h*1.75];


extendFrame(src1, img0, method);
ChannelCopyFit(img0, dest, kalpha, kred, kgreen, kblue);