filter "Vingette Tests";
group "BETA";

input centerPt, "Center", Point, 0, 0;
input doOval, "do Oval", Checkbox, 0;

input divisor, "divisor", Slider, 25, 1, 50;

input doBlur, "do Blur", Checkbox, 1;
input showChannels, "Show Channels", Checkbox, 0;

input outerColor, "outerColor", Color, 255, 127, 22, 0;
input outerColorOpacity, "outerColorOpacity", Slider, 50, 0, 255;

input innerColor, "End Color", Color, 255, 11, 22, 120;
input innerColorOpacity, "innerColorOpacity", Slider, 200, 0, 255;

input checkAlpha, "checkAlpha", Checkbox, 0;



producesalpha;
//	InformationFlag("YUVaware");

code

exposedBackground=1;





// INCLUDE "RGBtoYUVcolor.fxscript" r160

on RGBtoYUVcolor(color _rgbColor)
	color _temp;
	_temp = _rgbColor
	_rgbColor.r = _temp.r * 0.299 + _temp.g * 0.587 + _temp.b * 0.114 
	_rgbColor.g = _temp.r * -0.169 + _temp.g * -0.332 + _temp.b * 0.500 + 128; 
	_rgbColor.b = _temp.r * 0.500 + _temp.g * -0.419 + _temp.b * -0.0813 + 128;
end 

// END "RGBtoYUVcolor.fxscript"




// INCLUDE "NumReporter.fxscript" r247

on NumReporter(image _destIMG, value _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)
	
	float rw, rh, ra, rd;
	string reporter;
	color fontcolor;
	
	DimensionsOf(_destIMG, rw, rh);
	
	if (getPixelFormat(_destIMG)==kFormatYUV219)
		fontcolor = {255,235,128,128};
	else
		fontcolor = {255,235,235,235};
	end if
	settextfont("verdana");
	setTextstyle(kbold);
	setTextjustify(_justification);
	setTextSize(_fontsize);
													
	NumToString(_data, reporter, _numberformat);
	reporter = _label + " = " + reporter;
	DrawString(reporter, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));

end

// END "NumReporter.fxscript"


// INCLUDE "PtReporter.fxscript" r124

on PtReporter(image _destIMG, point _data, string _label, value _numberformat, value _h, value _fontsize, value _justification)
	
	float rw, rh, ra, rd, rzoom;
	string reporterX, reporterY;
	color fontcolor;
	
	DimensionsOf(_destIMG, rw, rh);
	rzoom = rw/720;
	
	fontcolor = {255,235,235,235};
	settextfont("verdana");
	setTextstyle(kbold);
	setTextjustify(_justification);
	setTextSize(_fontsize * rzoom);
													
	NumToString(_data.x, reporterX, _numberformat);
	NumToString(_data.y, reporterY, _numberformat);
	reporterX = _label + " = {" + reporterX + "," + reporterY + "}";
	DrawString(reporterX, 0, _h, 1.25,  _destIMG, fontcolor, aspectof(_destIMG));

end

// END "PtReporter.fxscript"

// INCLUDE "basic_math.fxscript" r128

on max(value _a, value _b); return (_a > _b) ? _a : _b; end 
on min(value _a, value _b); return (_a < _b) ? _a : _b; end 
on ceil(value _x); return(((_x - integer(_x)) > 0) ? integer(_x) + 1 : integer(_x)); end 
on floor(value _x); return(((_x - integer(_x)) < 0) ? integer(_x) - 1 : integer(_x)); end 

// END "basic_math.fxscript"


on InterpolateBox(point _box1, point _box2, value _percent, point _outBox)
	//	float _x;
	//	for _x = 0 to 3
	//		Interpolate(_box1[_x], _box2[_x], _percent, _outBox[_x]);
	//	next;
	
	_outBox = _box2;
	_outBox -= _box1;
	_outBox *= _percent;
	_outBox += _box1;
end



on vignette(image _dest, point _startPoly, point _endPoly, color _outerColor, color _innerColor, value _doOval)
	// could add color ramp bending by using the ease functions
	// instead of reversing the loop here, reverse the input polys

	// DEPENDENCIES:
	//		basic math
	//		InterpolateBox
	
	
	float _iterations, _i, _w, _h, _colorSpace;
	point _iBox[4];
	color _iColor;
	
//	_colorSpace = GetPixelFormat(_dest);

	DimensionsOf(dest, _w, _h);
	image _img[_w][_h], _bummer[_w][_h];
	
	channelfill(_img, 255, 255, 255, 255)
	channelfill(_bummer, 255, 255, 255, 255)
	
	if (doOval)
		_startPoly *= 2 * cos(45);
	end if
	
	/// calculate iterations by max vertex distance between the two polys
	_iterations = integer(max(distTo(_startPoly[0], _endPoly[0]), max(distTo(_startPoly[1], _endPoly[1]), max(distTo(_startPoly[2], _endPoly[2]), distTo(_startPoly[3], _endPoly[3])))));
	_iterations /= divisor;
	_iterations = min(_iterations, _w/2);	// limit _iterations to half the width of the frame to prevent runoffs with large frames and off-screen placement
	
	_iColor = {255, _outerColor.a,0, 0}; // setup initial fill color
	if (doOval)
		FillPoly(_startPoly, _dest, _iColor);	// fill _startPoly first to eliminate circle edges
	end if

	//	_iColor *= 0;
	//	_iColor += 255;
	for _i = 0 to _iterations
		interpolateBox(_startPoly, _endPoly, _i/_iterations, _iBox)

			// use red for input alpha mask
			// use green for full alpha transition
			_iColor.r = (_outerColor.a - _innerColor.a) * (1-_i/_iterations) + _innerColor.a;
			_iColor.g = (_i/_iterations) * 255;
		
		if (_doOval)
			frameOval(_iBox, _dest, _iColor, divisor+3)
		else 
			FramePoly(_iBox, _dest, _iColor, divisor+1);
		end if
		
	next;
	
	_iColor = {255, _innerColor.a, 255, 0}; // setup ending fill color
	
	if (doOval)
		FillOval(_endPoly, _dest, _iColor)
		frameOval(_endPoly, _dest, _iColor, divisor+3)
	else
		FillPoly(_endPoly, _dest, _iColor);
		FramePoly(_endPoly, _dest, _iColor, divisor+1);
	end if
		
	if (doBlur)
		BlurChannel(_dest, _img, divisor, 1, 1, 1, 1, AspectOf(_dest));
	else
	 	_img = _dest;
	end if
	
	//	SetPixelFormat(_img, kFormatRGB255);
	//	SetPixelFormat(_dest, kFormatRGB255);

	if (!showChannels)
		ChannelFill(_bummer, 255, _innerColor.r, _innerColor.g, _innerColor.b);
		ChannelFill(_dest, 255, _outerColor.r, _outerColor.g, _outerColor.b);
		ChannelCopy(_img, _bummer, kgreen, knone, knone, knone);	// move full gradient to start color channel
		Matte(_bummer, _dest, _dest, 1, kAlpha);
		//channelfill(dest, 255, -1, -1, -1)
		ChannelCopy(_img, _dest, kred, knone, knone, knone);
		
	//ChannelCopy(_img, _dest, kred, knone, knone, knone);		
	//ChannelCopy(_img, _dest, kalpha, knone, knone, knone);


	//	ChannelCopy(_img, _dest, knone, kred, kred, kred);

		//	ChannelCopy(_img, _img, kred, knone, knone, knone);
		//		ChannelCopy(_dest, _img, knone, kred, kgreen, kblue);
		//		_dest = _img
	
		if (checkAlpha)

			ChannelCopy(_dest, _dest, knone, kalpha,kalpha,kalpha);
			ChannelFill(_dest, 255, -1, -1, -1);
		end if
	
	 
	else 

	channelfill(_img, 255, -1, 0, 0)
		//	ChannelFill(_dest, 255, 255, 0, 0);
		//	ChannelCopy(_img, _img, kred, knone, knone, knone);
		//	
		//	ChannelCopy(_img, _dest, kalpha, knone, knone, knone);
		
			dest = _img; //channelcopy(_img, _dest, knone, kred, kgreen, kred)
	end if
	
//	SetPixelFormat(_dest, _colorSpace);

end




point dims;

DimensionsOf(dest, dims.x, dims.y);
centerPt *= dims;

point b1[4], b2[4], b3[4];

BoundsOf(dest, b1);
MakeRect(b2, centerPt.x, centerPt.y, 30, 55);
InterpolateBox(b1, b2, 0.5, b3);

//	RGBtoYUVcolor(outerColor);
//	RGBtoYUVcolor(innerColor);

outerColor.a = outerColorOpacity;
innerColor.a = innerColorOpacity;

vignette(dest, b1, b2, outerColor, innerColor, doOval)
//Matte(dest, src1, dest, 1, kAlpha);



//	WHY IS THE SECONDARY COLOR SHOWING UP TRANSPARENT?
	// because of a bug in ChannelCopy regarding unspecified image buffers